{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Simple library for instrumenting code to record dimensional time series. If you are new to the library it is highly recommended to read the pages in the Getting Started section on the sidebar. At a minimum you will need to: Depend on the api library. It is in maven central, for gradle the dependency would be com.netflix.spectator:spectator-api:0.83.0 . Instrument some code, see the usage guides for counters , timers , and gauges . Pick a registry to bind to when initializing the application. See the sidebar for a list of available registries.","title":"Home"},{"location":"reports/","text":"Build Reports These are automated reports generated from the build.","title":"Build Reports"},{"location":"reports/#build-reports","text":"These are automated reports generated from the build.","title":"Build Reports"},{"location":"ext/jvm-buffer-pools/","text":"Buffer Pools Buffer pools, such as direct byte buffers, can be monitored at a high level using the BufferPoolMXBean provided by the JDK. Getting Started To get information about buffer pools in spectator just setup registration of standard MXBeans. Note, if you are building an app at Netflix this should happen automatically via the normal platform initialization. import com.netflix.spectator.api.Spectator ; import com.netflix.spectator.jvm.Jmx ; Jmx . registerStandardMXBeans ( Spectator . registry ()); Metrics jvm.buffer.count Gauge showing the current number of distinct buffers. Unit: count Dimensions: id : type of buffers. Value will be either direct for direct byte buffers or mapped for memory mapped files. jvm.buffer.memoryUsed Gauge showing the current number of bytes used by all buffers. Unit: bytes Dimensions: id : type of buffers. Value will be either direct for direct byte buffers or mapped for memory mapped files.","title":"Buffer Pools"},{"location":"ext/jvm-buffer-pools/#buffer-pools","text":"Buffer pools, such as direct byte buffers, can be monitored at a high level using the BufferPoolMXBean provided by the JDK.","title":"Buffer Pools"},{"location":"ext/jvm-buffer-pools/#getting-started","text":"To get information about buffer pools in spectator just setup registration of standard MXBeans. Note, if you are building an app at Netflix this should happen automatically via the normal platform initialization. import com.netflix.spectator.api.Spectator ; import com.netflix.spectator.jvm.Jmx ; Jmx . registerStandardMXBeans ( Spectator . registry ());","title":"Getting Started"},{"location":"ext/jvm-buffer-pools/#metrics","text":"","title":"Metrics"},{"location":"ext/jvm-buffer-pools/#jvmbuffercount","text":"Gauge showing the current number of distinct buffers. Unit: count Dimensions: id : type of buffers. Value will be either direct for direct byte buffers or mapped for memory mapped files.","title":"jvm.buffer.count"},{"location":"ext/jvm-buffer-pools/#jvmbuffermemoryused","text":"Gauge showing the current number of bytes used by all buffers. Unit: bytes Dimensions: id : type of buffers. Value will be either direct for direct byte buffers or mapped for memory mapped files.","title":"jvm.buffer.memoryUsed"},{"location":"ext/jvm-gc-causes/","text":"GC Causes The various GC causes aren't well documented. The list provided here comes from the gcCause.cpp file in the jdk and we include some information on what these mean for the application. System.gc__ Something called System.gc() . If you are seeing this once an hour it is likely related to the RMI GC interval. For more details see: Unexplained System.gc() calls due to Remote Method Invocation (RMI) or explict garbage collections sun.rmi.dgc.client.gcInterval FullGCAlot Most likely you'll never see this value. In debug builds of the jdk there is an option, -XX:+FullGCALot , that will trigger a full GC at a regular interval for testing purposes. ScavengeAlot Most likely you'll never see this value. In debug builds of the jdk there is an option, -XX:+ScavengeALot , that will trigger a minor GC at a regular interval for testing purposes. Allocation_Profiler Prior to java 8 you would see this if running with the -Xaprof setting. It would be triggered just before the jvm exits. The -Xaprof option was removed in java 8. JvmtiEnv_ForceGarbageCollection Something called the JVM tool interface function ForceGarbageCollection . Look at the -agentlib param to java to see what agents are configured. GCLocker_Initiated_GC The GC locker prevents GC from occurring when JNI code is in a critical region . If GC is needed while a thread is in a critical region, then it will allow them to complete, i.e. call the corresponding release function. Other threads will not be permitted to enter a critical region. Once all threads are out of critical regions a GC event will be triggered. Heap_Inspection_Initiated_GC GC was initiated by an inspection operation on the heap. For example you can trigger this with jmap : $ jmap -histo:live pid Heap_Dump_Initiated_GC GC was initiated before dumping the heap. For example you can trigger this with jmap : $ jmap -dump:live,format=b,file=heap.out pid Another common example would be clicking the Heap Dump button on the Monitor tab in jvisualvm . WhiteBox_Initiated_Young_GC Most likely you'll never see this value. Used for testing hotspot, it indicates something called sun.hotspot.WhiteBox.youngGC() . No_GC Used for CMS to indicate concurrent phases. Allocation_Failure Usually this means that there is an allocation request that is bigger than the available space in young generation and will typically be associated with a minor GC. For G1 this will likely be a major GC and it is more common to see G1_Evacuation_Pause for routine minor collections. On linux the jvm will trigger a GC if the kernel indicates there isn't much memory left via mem_notify . Tenured_Generation_Full Not used? Permanent_Generation_Full Triggered as a result of an allocation failure in PermGen . Pre java 8. Metadata_GC_Threshold Triggered as a result of an allocation failure in Metaspace . Metaspace replaced PermGen was added in java 8. CMS_Generation_Full Not used? CMS_Initial_Mark Initial mark phase of CMS, for more details see Phases of CMS . Unfortunately it doesn't appear to be reported via the mbeans and we just get No_GC . CMS_Final_Remark Remark phase of CMS, for more details see Phases of CMS . Unfortunately it doesn't appear to be reported via the mbeans and we just get No_GC . CMS_Concurrent_Mark Concurrent mark phase of CMS, for more details see Phases of CMS . Unfortunately it doesn't appear to be reported via the mbeans and we just get No_GC . Old_Generation_Expanded_On_Last_Scavenge Not used? Old_Generation_Too_Full_To_Scavenge Not used? Ergonomics This indicates you are using the adaptive size policy, -XX:+UseAdaptiveSizePolicy and is on by default for recent versions, with the parallel collector ( -XX:+UseParallelGC ). For more details see The Why of GC Ergonomics . G1_Evacuation_Pause An evacuation pause is the most common young gen cause for G1 and indicates that it is copying live objects from one set of regions, young and sometimes young + old, to another set of regions. For more details see Understanding G1 GC Logs . G1_Humongous_Allocation A humongous allocation is one where the size is greater than 50% of the G1 region size. Before a humongous allocation the jvm checks if it should do a routine evacuation pause without regard to the actual allocation size, but if triggered due to this check the cause will be listed as humongous allocation. This cause is also used for any collections used to free up enough space for the allocation. Last_ditch_collection For perm gen (java 7 or earlier) and metaspace (java 8+) a last ditch collection will be triggered if an allocation fails and the memory pool cannot be expanded. ILLEGAL_VALUE_- last_gc_cause -_ILLEGAL_VALUE Included for completeness, but you should never see this value. unknown_GCCause Included for completeness, but you should never see this value.","title":"GC Causes"},{"location":"ext/jvm-gc-causes/#gc-causes","text":"The various GC causes aren't well documented. The list provided here comes from the gcCause.cpp file in the jdk and we include some information on what these mean for the application.","title":"GC Causes"},{"location":"ext/jvm-gc-causes/#systemgc__","text":"Something called System.gc() . If you are seeing this once an hour it is likely related to the RMI GC interval. For more details see: Unexplained System.gc() calls due to Remote Method Invocation (RMI) or explict garbage collections sun.rmi.dgc.client.gcInterval","title":"System.gc__"},{"location":"ext/jvm-gc-causes/#fullgcalot","text":"Most likely you'll never see this value. In debug builds of the jdk there is an option, -XX:+FullGCALot , that will trigger a full GC at a regular interval for testing purposes.","title":"FullGCAlot"},{"location":"ext/jvm-gc-causes/#scavengealot","text":"Most likely you'll never see this value. In debug builds of the jdk there is an option, -XX:+ScavengeALot , that will trigger a minor GC at a regular interval for testing purposes.","title":"ScavengeAlot"},{"location":"ext/jvm-gc-causes/#allocation_profiler","text":"Prior to java 8 you would see this if running with the -Xaprof setting. It would be triggered just before the jvm exits. The -Xaprof option was removed in java 8.","title":"Allocation_Profiler"},{"location":"ext/jvm-gc-causes/#jvmtienv_forcegarbagecollection","text":"Something called the JVM tool interface function ForceGarbageCollection . Look at the -agentlib param to java to see what agents are configured.","title":"JvmtiEnv_ForceGarbageCollection"},{"location":"ext/jvm-gc-causes/#gclocker_initiated_gc","text":"The GC locker prevents GC from occurring when JNI code is in a critical region . If GC is needed while a thread is in a critical region, then it will allow them to complete, i.e. call the corresponding release function. Other threads will not be permitted to enter a critical region. Once all threads are out of critical regions a GC event will be triggered.","title":"GCLocker_Initiated_GC"},{"location":"ext/jvm-gc-causes/#heap_inspection_initiated_gc","text":"GC was initiated by an inspection operation on the heap. For example you can trigger this with jmap : $ jmap -histo:live pid","title":"Heap_Inspection_Initiated_GC"},{"location":"ext/jvm-gc-causes/#heap_dump_initiated_gc","text":"GC was initiated before dumping the heap. For example you can trigger this with jmap : $ jmap -dump:live,format=b,file=heap.out pid Another common example would be clicking the Heap Dump button on the Monitor tab in jvisualvm .","title":"Heap_Dump_Initiated_GC"},{"location":"ext/jvm-gc-causes/#whitebox_initiated_young_gc","text":"Most likely you'll never see this value. Used for testing hotspot, it indicates something called sun.hotspot.WhiteBox.youngGC() .","title":"WhiteBox_Initiated_Young_GC"},{"location":"ext/jvm-gc-causes/#no_gc","text":"Used for CMS to indicate concurrent phases.","title":"No_GC"},{"location":"ext/jvm-gc-causes/#allocation_failure","text":"Usually this means that there is an allocation request that is bigger than the available space in young generation and will typically be associated with a minor GC. For G1 this will likely be a major GC and it is more common to see G1_Evacuation_Pause for routine minor collections. On linux the jvm will trigger a GC if the kernel indicates there isn't much memory left via mem_notify .","title":"Allocation_Failure"},{"location":"ext/jvm-gc-causes/#tenured_generation_full","text":"Not used?","title":"Tenured_Generation_Full"},{"location":"ext/jvm-gc-causes/#permanent_generation_full","text":"Triggered as a result of an allocation failure in PermGen . Pre java 8.","title":"Permanent_Generation_Full"},{"location":"ext/jvm-gc-causes/#metadata_gc_threshold","text":"Triggered as a result of an allocation failure in Metaspace . Metaspace replaced PermGen was added in java 8.","title":"Metadata_GC_Threshold"},{"location":"ext/jvm-gc-causes/#cms_generation_full","text":"Not used?","title":"CMS_Generation_Full"},{"location":"ext/jvm-gc-causes/#cms_initial_mark","text":"Initial mark phase of CMS, for more details see Phases of CMS . Unfortunately it doesn't appear to be reported via the mbeans and we just get No_GC .","title":"CMS_Initial_Mark"},{"location":"ext/jvm-gc-causes/#cms_final_remark","text":"Remark phase of CMS, for more details see Phases of CMS . Unfortunately it doesn't appear to be reported via the mbeans and we just get No_GC .","title":"CMS_Final_Remark"},{"location":"ext/jvm-gc-causes/#cms_concurrent_mark","text":"Concurrent mark phase of CMS, for more details see Phases of CMS . Unfortunately it doesn't appear to be reported via the mbeans and we just get No_GC .","title":"CMS_Concurrent_Mark"},{"location":"ext/jvm-gc-causes/#old_generation_expanded_on_last_scavenge","text":"Not used?","title":"Old_Generation_Expanded_On_Last_Scavenge"},{"location":"ext/jvm-gc-causes/#old_generation_too_full_to_scavenge","text":"Not used?","title":"Old_Generation_Too_Full_To_Scavenge"},{"location":"ext/jvm-gc-causes/#ergonomics","text":"This indicates you are using the adaptive size policy, -XX:+UseAdaptiveSizePolicy and is on by default for recent versions, with the parallel collector ( -XX:+UseParallelGC ). For more details see The Why of GC Ergonomics .","title":"Ergonomics"},{"location":"ext/jvm-gc-causes/#g1_evacuation_pause","text":"An evacuation pause is the most common young gen cause for G1 and indicates that it is copying live objects from one set of regions, young and sometimes young + old, to another set of regions. For more details see Understanding G1 GC Logs .","title":"G1_Evacuation_Pause"},{"location":"ext/jvm-gc-causes/#g1_humongous_allocation","text":"A humongous allocation is one where the size is greater than 50% of the G1 region size. Before a humongous allocation the jvm checks if it should do a routine evacuation pause without regard to the actual allocation size, but if triggered due to this check the cause will be listed as humongous allocation. This cause is also used for any collections used to free up enough space for the allocation.","title":"G1_Humongous_Allocation"},{"location":"ext/jvm-gc-causes/#last_ditch_collection","text":"For perm gen (java 7 or earlier) and metaspace (java 8+) a last ditch collection will be triggered if an allocation fails and the memory pool cannot be expanded.","title":"Last_ditch_collection"},{"location":"ext/jvm-gc-causes/#illegal_value_-last_gc_cause-_illegal_value","text":"Included for completeness, but you should never see this value.","title":"ILLEGAL_VALUE_-last_gc_cause-_ILLEGAL_VALUE"},{"location":"ext/jvm-gc-causes/#unknown_gccause","text":"Included for completeness, but you should never see this value.","title":"unknown_GCCause"},{"location":"ext/jvm-gc/","text":"Garbage Collection The GC module registers with the notification emitter of the GarbageCollectorMXBean to provide some basic GC logging and metrics. Getting started Logging Metrics Alerting Getting Started For using it internally at Netflix see the Netflix integration guide, otherwise keep reading this section. Requirements This library relies on the notification emitter added in 7u4, but there are known issues prior to 7u40. There is also a regression impacting java 9 and higher, see #502 and JDK-8196325 for more information. For G1 it is recommended to be on the latest version available. Dependencies com.netflix.spectator:spectator-ext-gc:0.83.0 Start Reporting Then in the initialization for the application: import com.netflix.spectator.gc.GcLogger ; ... // Keep a single instance of the logger GcLogger gc = new GcLogger (); gc . start ( null ); Logging After GC events an INFO level log message will get reported using slf4j. This makes it easy to GC events in the context of other log messages for the application. The logger name is com.netflix.spectator.gc.GcLogger and the message will look like: ${ GC_TYPE } : ${ COLLECTOR_NAME } , id= ${ N } , at= ${ START_TIME } , duration= ${ T } ms, cause=[ ${ CAUSE } ], ${ TOTAL_USAGE_BEFORE } = ${ TOTAL_USAGE_AFTER } / ${ MAX_SIZE } ( ${ PERCENT_USAGE_BEFORE } = ${ PERCENT_USAGE_AFTER } ) The id can be used to verify events were not skipped or correlate with other sources like detailed GC logs. See GC causes for more details on the possible causes. Sample: 2014 - 08 - 31 02 : 02 : 24 , 724 INFO [ com . netflix . spectator . gc . GcLogger ] YOUNG : ParNew , id = 5281 , at = Sun Aug 31 02 : 02 : 24 UTC 2014 , duration = 2 ms , cause = [ Allocation Failure ], 0.4 G = 0.3 G / 1.8 G ( 24.3 % = 16.6 % ) Metrics jvm.gc.allocationRate The allocation rate measures how fast the application is allocating memory. It is a counter that is incremented after a GC event by the amount youngGen.sizeBeforeGC . Technically, right now it is: youngGen.sizeBeforeGC - youngGen.sizeAfterGC However, youngGen.sizeAfterGC should be 0 and thus the size of young gen before the GC is the amount allocated since the previous GC event. Unit: bytes/second Dimensions: n/a jvm.gc.promotionRate The promotion rate measures how fast data is being moved from young generation into the old generation. It is a counter that is incremented after a GC event by the amount: abs(oldGen.sizeAfterGC - oldGen.sizeBeforeGC) Unit: bytes/second Dimensions: n/a jvm.gc.liveDataSize The live data size is the size of the old generation after a major GC. The image below shows how the live data size view compares to a metric showing the current size of the memory pool: Unit: bytes Dimensions: n/a jvm.gc.maxDataSize Maximum size for the old generation. Primary use-case is for gaining perspective on the the live data size. Unit: bytes Dimensions: n/a jvm.gc.pause Timer reporting the pause time for a GC event. All of the values reported are stop the world pauses. Unit: statistic=max : seconds statistic=count : events/second statistic=totalTime : seconds/second Dimensions: action : action performed by the garbage collector ( javadoc ). There is no guarantee, but the typical values seen are end_of_major_GC and end_of_minor_GC . cause : cause that instigated GC ( javadoc ). For an explanation of common causes see the GC causes page. jvm.gc.concurrentPhaseTime Timer reporting time spent in concurrent phases of CMS. pauses. Unit: statistic=max : seconds statistic=count : events/second statistic=totalTime : seconds/second Dimensions: action : action performed by the garbage collector ( javadoc ). There is no guarantee, but the typical values seen are end_of_major_GC and end_of_minor_GC . cause : cause that instigated GC ( javadoc ). For an explanation of common causes see the GC causes page. Alerting This section assumes the data is available in Atlas , but users of other systems should be able to take the idea and make it work. For all of these alerts it is recommended to check them on instance. At Netflix that can be done by selecting the option in alert ui: Max Pause Time Example to trigger an alert if the pause time exceeds 500 milliseconds: name,jvm.gc.pause,:eq, statistic,max,:eq, :and, :max,(,cause,),:by, 0.5,:gt, $cause,:legend Heap Pressure Example to trigger an alert if the live data size is over 70% of the heap: name,jvm.gc.liveDataSize,:eq,:max, name,jvm.gc.maxDataSize,:eq,:max, :div,100,:mul, 70,:gt, percentUsed,:legend","title":"Garbage Collection"},{"location":"ext/jvm-gc/#garbage-collection","text":"The GC module registers with the notification emitter of the GarbageCollectorMXBean to provide some basic GC logging and metrics. Getting started Logging Metrics Alerting","title":"Garbage Collection"},{"location":"ext/jvm-gc/#getting-started","text":"For using it internally at Netflix see the Netflix integration guide, otherwise keep reading this section.","title":"Getting Started"},{"location":"ext/jvm-gc/#requirements","text":"This library relies on the notification emitter added in 7u4, but there are known issues prior to 7u40. There is also a regression impacting java 9 and higher, see #502 and JDK-8196325 for more information. For G1 it is recommended to be on the latest version available.","title":"Requirements"},{"location":"ext/jvm-gc/#dependencies","text":"com.netflix.spectator:spectator-ext-gc:0.83.0","title":"Dependencies"},{"location":"ext/jvm-gc/#start-reporting","text":"Then in the initialization for the application: import com.netflix.spectator.gc.GcLogger ; ... // Keep a single instance of the logger GcLogger gc = new GcLogger (); gc . start ( null );","title":"Start Reporting"},{"location":"ext/jvm-gc/#logging","text":"After GC events an INFO level log message will get reported using slf4j. This makes it easy to GC events in the context of other log messages for the application. The logger name is com.netflix.spectator.gc.GcLogger and the message will look like: ${ GC_TYPE } : ${ COLLECTOR_NAME } , id= ${ N } , at= ${ START_TIME } , duration= ${ T } ms, cause=[ ${ CAUSE } ], ${ TOTAL_USAGE_BEFORE } = ${ TOTAL_USAGE_AFTER } / ${ MAX_SIZE } ( ${ PERCENT_USAGE_BEFORE } = ${ PERCENT_USAGE_AFTER } ) The id can be used to verify events were not skipped or correlate with other sources like detailed GC logs. See GC causes for more details on the possible causes. Sample: 2014 - 08 - 31 02 : 02 : 24 , 724 INFO [ com . netflix . spectator . gc . GcLogger ] YOUNG : ParNew , id = 5281 , at = Sun Aug 31 02 : 02 : 24 UTC 2014 , duration = 2 ms , cause = [ Allocation Failure ], 0.4 G = 0.3 G / 1.8 G ( 24.3 % = 16.6 % )","title":"Logging"},{"location":"ext/jvm-gc/#metrics","text":"","title":"Metrics"},{"location":"ext/jvm-gc/#jvmgcallocationrate","text":"The allocation rate measures how fast the application is allocating memory. It is a counter that is incremented after a GC event by the amount youngGen.sizeBeforeGC . Technically, right now it is: youngGen.sizeBeforeGC - youngGen.sizeAfterGC However, youngGen.sizeAfterGC should be 0 and thus the size of young gen before the GC is the amount allocated since the previous GC event. Unit: bytes/second Dimensions: n/a","title":"jvm.gc.allocationRate"},{"location":"ext/jvm-gc/#jvmgcpromotionrate","text":"The promotion rate measures how fast data is being moved from young generation into the old generation. It is a counter that is incremented after a GC event by the amount: abs(oldGen.sizeAfterGC - oldGen.sizeBeforeGC) Unit: bytes/second Dimensions: n/a","title":"jvm.gc.promotionRate"},{"location":"ext/jvm-gc/#jvmgclivedatasize","text":"The live data size is the size of the old generation after a major GC. The image below shows how the live data size view compares to a metric showing the current size of the memory pool: Unit: bytes Dimensions: n/a","title":"jvm.gc.liveDataSize"},{"location":"ext/jvm-gc/#jvmgcmaxdatasize","text":"Maximum size for the old generation. Primary use-case is for gaining perspective on the the live data size. Unit: bytes Dimensions: n/a","title":"jvm.gc.maxDataSize"},{"location":"ext/jvm-gc/#jvmgcpause","text":"Timer reporting the pause time for a GC event. All of the values reported are stop the world pauses. Unit: statistic=max : seconds statistic=count : events/second statistic=totalTime : seconds/second Dimensions: action : action performed by the garbage collector ( javadoc ). There is no guarantee, but the typical values seen are end_of_major_GC and end_of_minor_GC . cause : cause that instigated GC ( javadoc ). For an explanation of common causes see the GC causes page.","title":"jvm.gc.pause"},{"location":"ext/jvm-gc/#jvmgcconcurrentphasetime","text":"Timer reporting time spent in concurrent phases of CMS. pauses. Unit: statistic=max : seconds statistic=count : events/second statistic=totalTime : seconds/second Dimensions: action : action performed by the garbage collector ( javadoc ). There is no guarantee, but the typical values seen are end_of_major_GC and end_of_minor_GC . cause : cause that instigated GC ( javadoc ). For an explanation of common causes see the GC causes page.","title":"jvm.gc.concurrentPhaseTime"},{"location":"ext/jvm-gc/#alerting","text":"This section assumes the data is available in Atlas , but users of other systems should be able to take the idea and make it work. For all of these alerts it is recommended to check them on instance. At Netflix that can be done by selecting the option in alert ui:","title":"Alerting"},{"location":"ext/jvm-gc/#max-pause-time","text":"Example to trigger an alert if the pause time exceeds 500 milliseconds: name,jvm.gc.pause,:eq, statistic,max,:eq, :and, :max,(,cause,),:by, 0.5,:gt, $cause,:legend","title":"Max Pause Time"},{"location":"ext/jvm-gc/#heap-pressure","text":"Example to trigger an alert if the live data size is over 70% of the heap: name,jvm.gc.liveDataSize,:eq,:max, name,jvm.gc.maxDataSize,:eq,:max, :div,100,:mul, 70,:gt, percentUsed,:legend","title":"Heap Pressure"},{"location":"ext/jvm-memory-pools/","text":"Memory Pools Uses the MemoryPoolMXBean provided by the JDK to monitor the sizes of java memory spaces such as perm gen, eden, old gen, etc. Getting Started To get information about memory pools in spectator just setup registration of standard MXBeans. Note, if you are building an app at Netflix this should happen automatically via the normal platform initialization. import com.netflix.spectator.api.Spectator ; import com.netflix.spectator.jvm.Jmx ; Jmx . registerStandardMXBeans ( Spectator . registry ()); Metrics jvm.memory.used Gauge reporting the current amount of memory used. For the young and old gen pools this metric will typically have a sawtooth pattern. For alerting or detecting memory pressure the live data size is probably a better option. Unit: bytes Dimensions: see metric dimensions jvm.memory.committed Gauge reporting the current amount of memory committed. From the javadocs , committed is: The amount of memory (in bytes) that is guaranteed to be available for use by the Java virtual machine. The amount of committed memory may change over time (increase or decrease). The Java virtual machine may release memory to the system and committed could be less than init. committed will always be greater than or equal to used. Unit: bytes Dimensions: see metric dimensions jvm.memory.max Gauge reporting the max amount of memory that can be used. From the javadocs , max is: The maximum amount of memory (in bytes) that can be used for memory management. Its value may be undefined. The maximum amount of memory may change over time if defined. The amount of used and committed memory will always be less than or equal to max if max is defined. A memory allocation may fail if it attempts to increase the used memory such that used committed even if used = max would still be true (for example, when the system is low on virtual memory). Unit: bytes Dimensions: see metric dimensions Metric Dimensions All memory metrics have the following dimensions: id : name of the memory pool being reported. The names of the pools vary depending on the garbage collector algorithm being used. memtype : type of memory. It has two possible values: HEAP and NON_HEAP . For more information see the javadocs for MemoryType .","title":"Memory Pools"},{"location":"ext/jvm-memory-pools/#memory-pools","text":"Uses the MemoryPoolMXBean provided by the JDK to monitor the sizes of java memory spaces such as perm gen, eden, old gen, etc.","title":"Memory Pools"},{"location":"ext/jvm-memory-pools/#getting-started","text":"To get information about memory pools in spectator just setup registration of standard MXBeans. Note, if you are building an app at Netflix this should happen automatically via the normal platform initialization. import com.netflix.spectator.api.Spectator ; import com.netflix.spectator.jvm.Jmx ; Jmx . registerStandardMXBeans ( Spectator . registry ());","title":"Getting Started"},{"location":"ext/jvm-memory-pools/#metrics","text":"","title":"Metrics"},{"location":"ext/jvm-memory-pools/#jvmmemoryused","text":"Gauge reporting the current amount of memory used. For the young and old gen pools this metric will typically have a sawtooth pattern. For alerting or detecting memory pressure the live data size is probably a better option. Unit: bytes Dimensions: see metric dimensions","title":"jvm.memory.used"},{"location":"ext/jvm-memory-pools/#jvmmemorycommitted","text":"Gauge reporting the current amount of memory committed. From the javadocs , committed is: The amount of memory (in bytes) that is guaranteed to be available for use by the Java virtual machine. The amount of committed memory may change over time (increase or decrease). The Java virtual machine may release memory to the system and committed could be less than init. committed will always be greater than or equal to used. Unit: bytes Dimensions: see metric dimensions","title":"jvm.memory.committed"},{"location":"ext/jvm-memory-pools/#jvmmemorymax","text":"Gauge reporting the max amount of memory that can be used. From the javadocs , max is: The maximum amount of memory (in bytes) that can be used for memory management. Its value may be undefined. The maximum amount of memory may change over time if defined. The amount of used and committed memory will always be less than or equal to max if max is defined. A memory allocation may fail if it attempts to increase the used memory such that used committed even if used = max would still be true (for example, when the system is low on virtual memory). Unit: bytes Dimensions: see metric dimensions","title":"jvm.memory.max"},{"location":"ext/jvm-memory-pools/#metric-dimensions","text":"All memory metrics have the following dimensions: id : name of the memory pool being reported. The names of the pools vary depending on the garbage collector algorithm being used. memtype : type of memory. It has two possible values: HEAP and NON_HEAP . For more information see the javadocs for MemoryType .","title":"Metric Dimensions"},{"location":"ext/log4j1/","text":"Log4j1 Appender Custom appender for log4j1 to track the number of log messages reported. Note Log4j 1.x has reached end of life and is no longer supported by Apache. This extension is provided for some users that have difficulty moving to a supported version of log4j. Getting Started To use it simply add a dependency: com.netflix.spectator:spectator-ext-log4j1:0.83.0 Then in your log4j configuration specify the com.netflix.spectator.log4j.SpectatorAppender . In a properties file it would look something like: log4j.rootLogger=ALL, A1 log4j.appender.A1=com.netflix.spectator.log4j.SpectatorAppender Metrics log4j.numMessages Counters showing the number of messages that have been passed to the appender. Unit: messages/second Dimensions: loglevel : standard log level of the events. log4j.numStackTraces Counter for the number of messages with stack traces written to the logs. Unit: messages/second Dimensions: loglevel : standard log level of the events. exception : simple class name for the exception that was thrown. file : file name for where the exception was thrown.","title":"Log4j1 Appender"},{"location":"ext/log4j1/#log4j1-appender","text":"Custom appender for log4j1 to track the number of log messages reported. Note Log4j 1.x has reached end of life and is no longer supported by Apache. This extension is provided for some users that have difficulty moving to a supported version of log4j.","title":"Log4j1 Appender"},{"location":"ext/log4j1/#getting-started","text":"To use it simply add a dependency: com.netflix.spectator:spectator-ext-log4j1:0.83.0 Then in your log4j configuration specify the com.netflix.spectator.log4j.SpectatorAppender . In a properties file it would look something like: log4j.rootLogger=ALL, A1 log4j.appender.A1=com.netflix.spectator.log4j.SpectatorAppender","title":"Getting Started"},{"location":"ext/log4j1/#metrics","text":"","title":"Metrics"},{"location":"ext/log4j1/#log4jnummessages","text":"Counters showing the number of messages that have been passed to the appender. Unit: messages/second Dimensions: loglevel : standard log level of the events.","title":"log4j.numMessages"},{"location":"ext/log4j1/#log4jnumstacktraces","text":"Counter for the number of messages with stack traces written to the logs. Unit: messages/second Dimensions: loglevel : standard log level of the events. exception : simple class name for the exception that was thrown. file : file name for where the exception was thrown.","title":"log4j.numStackTraces"},{"location":"ext/log4j2/","text":"Log4j2 Appender Custom appender for log4j2 to track the number of log messages reported. Getting Started To use it simply add a dependency: com.netflix.spectator:spectator-ext-log4j2:0.83.0 Then in your application initialization: Registry registry = ... SpectatorAppender . addToRootLogger ( registry , // Registry to use spectator , // Name for the appender false ); // Should stack traces be ignored? This will add the appender to the root logger and register a listener so it will get re-added if the configuration changes. You can also use the appender by specifying it in the log4j2 configuration, but this will cause some of the loggers in Spectator to get created before log4j is properly initialized and result in some lost log messages. With that caveat in mind, if you need the additional flexibility of using the configuration then specify the Spectator appender: ?xml version= 1.0 encoding= UTF-8 ? Configuration monitorInterval= 5 status= warn Appenders Spectator name= root / /Appenders Loggers Root level= debug AppenderRef ref= root / /Root /Loggers /Configuration Metrics log4j.numMessages Counters showing the number of messages that have been passed to the appender. Unit: messages/second Dimensions: appender : name of the spectator appender. loglevel : standard log level of the events. log4j.numStackTraces Counter for the number of messages with stack traces written to the logs. This will only be collected if the ignoreExceptions flag is set to false for the appender. Unit: messages/second Dimensions: appender : name of the spectator appender. loglevel : standard log level of the events. exception : simple class name for the exception that was thrown. file : file name for where the exception was thrown.","title":"Log4j2 Appender"},{"location":"ext/log4j2/#log4j2-appender","text":"Custom appender for log4j2 to track the number of log messages reported.","title":"Log4j2 Appender"},{"location":"ext/log4j2/#getting-started","text":"To use it simply add a dependency: com.netflix.spectator:spectator-ext-log4j2:0.83.0 Then in your application initialization: Registry registry = ... SpectatorAppender . addToRootLogger ( registry , // Registry to use spectator , // Name for the appender false ); // Should stack traces be ignored? This will add the appender to the root logger and register a listener so it will get re-added if the configuration changes. You can also use the appender by specifying it in the log4j2 configuration, but this will cause some of the loggers in Spectator to get created before log4j is properly initialized and result in some lost log messages. With that caveat in mind, if you need the additional flexibility of using the configuration then specify the Spectator appender: ?xml version= 1.0 encoding= UTF-8 ? Configuration monitorInterval= 5 status= warn Appenders Spectator name= root / /Appenders Loggers Root level= debug AppenderRef ref= root / /Root /Loggers /Configuration","title":"Getting Started"},{"location":"ext/log4j2/#metrics","text":"","title":"Metrics"},{"location":"ext/log4j2/#log4jnummessages","text":"Counters showing the number of messages that have been passed to the appender. Unit: messages/second Dimensions: appender : name of the spectator appender. loglevel : standard log level of the events.","title":"log4j.numMessages"},{"location":"ext/log4j2/#log4jnumstacktraces","text":"Counter for the number of messages with stack traces written to the logs. This will only be collected if the ignoreExceptions flag is set to false for the appender. Unit: messages/second Dimensions: appender : name of the spectator appender. loglevel : standard log level of the events. exception : simple class name for the exception that was thrown. file : file name for where the exception was thrown.","title":"log4j.numStackTraces"},{"location":"ext/placeholders/","text":"Placeholders The placeholders extension allows for identifiers to be created with dimensions that will get filled in based on the context when an activity occurs. The primary use-cases are to support: Optional dimensions that can be conditionally enabled. Pulling dimensions from another context such as a thread local store. This can make it is easier to share the across various parts of the code. Dependencies To use the placeholders support add a dependency on: com.netflix.spectator:spectator-ext-placeholders:0.83.0 Usage Placeholder support is available for activity based types including counters , timers , and distribution summaries . To get started create a PlaceholderFactory from the registry: PlaceholderFactory factory = PlaceholderFactory . from ( registry ); Then use the factory to create an identifier using a TagFactory to dynamically fetch the value for a given dimension when some activity occurs. Suppose we want to use a dynamic configuration library such as Archaius to conditionally enable a dimension with high cardinality: public class Server { private final Context context ; private final Counter rps ; public Server ( Context context , PropertyFactory props , Registry registry ) { this . context = context ; // Property that can be dynamically updated to indicate whether or not // detailed dimensions should be added to metrics. Property Boolean enabled = props . getProperty ( server.detailedMetricsEnabled ) . asBoolean ( false ); // Factory for creating instances of the counter using placeholders PlaceholderFactory factory = PlaceholderFactory . from ( registry ); // Create the underlying id with 4 possible dimensions: // * method and status - low cardinality and always added if available // in the context. // * geo and device - high cardinality and only available if the property // to enable detailed metrics is set to true. PlaceholderId rpsId = factory . createId ( server.requests ) . withTagFactory ( TagFactory . from ( method , context :: getMethod )) . withTagFactory ( TagFactory . from ( status , context :: getStatus )) . withTagFactory ( new DetailedDimension ( geo , enabled , context :: getGeo )) . withTagFactory ( new DetailedDimension ( device , enabled , context :: getDevice )); rps = factory . counter ( rpsId ); } public Response handle ( Request request ) { fillInContext ( request ); Response response = process ( request ); fillInContext ( response ); // Update the counter, the placeholders will be resolved when the activity, in // this case the increment is called. rps . increment (); return response ; } // Tag factory that can be controlled with an enabled property. private static class DetailedDimension implements TagFactory { private final String name ; private final Supplier String valueFunc ; DetailedDimension ( String name , Property Boolean enabled , Supplier String valueFunc ) { this . name = name ; this . enabled = enabled ; this . valueFunc = valueFunc ; } @Override public String name () { return name ; } @Override public Tag createTag () { return enabled . get () ? new BasicTag ( name , valueFunc . get ()) : null ; } } }","title":"Placeholders"},{"location":"ext/placeholders/#placeholders","text":"The placeholders extension allows for identifiers to be created with dimensions that will get filled in based on the context when an activity occurs. The primary use-cases are to support: Optional dimensions that can be conditionally enabled. Pulling dimensions from another context such as a thread local store. This can make it is easier to share the across various parts of the code.","title":"Placeholders"},{"location":"ext/placeholders/#dependencies","text":"To use the placeholders support add a dependency on: com.netflix.spectator:spectator-ext-placeholders:0.83.0","title":"Dependencies"},{"location":"ext/placeholders/#usage","text":"Placeholder support is available for activity based types including counters , timers , and distribution summaries . To get started create a PlaceholderFactory from the registry: PlaceholderFactory factory = PlaceholderFactory . from ( registry ); Then use the factory to create an identifier using a TagFactory to dynamically fetch the value for a given dimension when some activity occurs. Suppose we want to use a dynamic configuration library such as Archaius to conditionally enable a dimension with high cardinality: public class Server { private final Context context ; private final Counter rps ; public Server ( Context context , PropertyFactory props , Registry registry ) { this . context = context ; // Property that can be dynamically updated to indicate whether or not // detailed dimensions should be added to metrics. Property Boolean enabled = props . getProperty ( server.detailedMetricsEnabled ) . asBoolean ( false ); // Factory for creating instances of the counter using placeholders PlaceholderFactory factory = PlaceholderFactory . from ( registry ); // Create the underlying id with 4 possible dimensions: // * method and status - low cardinality and always added if available // in the context. // * geo and device - high cardinality and only available if the property // to enable detailed metrics is set to true. PlaceholderId rpsId = factory . createId ( server.requests ) . withTagFactory ( TagFactory . from ( method , context :: getMethod )) . withTagFactory ( TagFactory . from ( status , context :: getStatus )) . withTagFactory ( new DetailedDimension ( geo , enabled , context :: getGeo )) . withTagFactory ( new DetailedDimension ( device , enabled , context :: getDevice )); rps = factory . counter ( rpsId ); } public Response handle ( Request request ) { fillInContext ( request ); Response response = process ( request ); fillInContext ( response ); // Update the counter, the placeholders will be resolved when the activity, in // this case the increment is called. rps . increment (); return response ; } // Tag factory that can be controlled with an enabled property. private static class DetailedDimension implements TagFactory { private final String name ; private final Supplier String valueFunc ; DetailedDimension ( String name , Property Boolean enabled , Supplier String valueFunc ) { this . name = name ; this . enabled = enabled ; this . valueFunc = valueFunc ; } @Override public String name () { return name ; } @Override public Tag createTag () { return enabled . get () ? new BasicTag ( name , valueFunc . get ()) : null ; } } }","title":"Usage"},{"location":"ext/thread-pools/","text":"Thread Pools Java's ThreadPoolExecutor exposes several properties that are useful to monitor to assess the health, performance, and configuration of the pool. Getting Started To report thread pool metrics, one can attach a ThreadPoolMonitor in the following manner: import com.netflix.spectator.api.patterns.ThreadPoolMonitor ; ThreadPoolMonitor . attach ( registry , myThreadPoolExecutor , my-thread-pool ); The thread pool's properties will be polled regularly in the background and will report metrics to the provided registry. The third parameter will be added to each metric as an id dimension, if provided. However, if the value is null or an empty string, then a default will be used as the id . Metrics threadpool.taskCount Counter of the total number of tasks that have been scheduled. Unit: tasks/second Data Source: ThreadPoolExecutor#getTaskCount() threadpool.completedTaskCount Counter of the total number of tasks that have completed. Unit: tasks/second Data Source: ThreadPoolExecutor#getCompletedTaskCount() threadpool.currentThreadsBusy Gauge showing the current number of threads actively doing work. Unit: count Data Source: ThreadPoolExecutor#getActiveCount() threadpool.maxThreads Gauge showing the current maximum number of threads configured for the pool. Unit: count Data Source: ThreadPoolExecutor#getMaximumPoolSize() threadpool.poolSize Gauge showing the current size of the pool. Unit: count Data Source: ThreadPoolExecutor#getPoolSize() threadpool.corePoolSize Gauge showing the current maximum number of core threads configured for the pool. Unit: count Data Source: ThreadPoolExecutor#getCorePoolSize() threadpool.queueSize Gauge showing the current number of threads queued for execution. Unit: count Data Source: ThreadPoolExecutor#getQueue().size()","title":"Thread Pools"},{"location":"ext/thread-pools/#thread-pools","text":"Java's ThreadPoolExecutor exposes several properties that are useful to monitor to assess the health, performance, and configuration of the pool.","title":"Thread Pools"},{"location":"ext/thread-pools/#getting-started","text":"To report thread pool metrics, one can attach a ThreadPoolMonitor in the following manner: import com.netflix.spectator.api.patterns.ThreadPoolMonitor ; ThreadPoolMonitor . attach ( registry , myThreadPoolExecutor , my-thread-pool ); The thread pool's properties will be polled regularly in the background and will report metrics to the provided registry. The third parameter will be added to each metric as an id dimension, if provided. However, if the value is null or an empty string, then a default will be used as the id .","title":"Getting Started"},{"location":"ext/thread-pools/#metrics","text":"","title":"Metrics"},{"location":"ext/thread-pools/#threadpooltaskcount","text":"Counter of the total number of tasks that have been scheduled. Unit: tasks/second Data Source: ThreadPoolExecutor#getTaskCount()","title":"threadpool.taskCount"},{"location":"ext/thread-pools/#threadpoolcompletedtaskcount","text":"Counter of the total number of tasks that have completed. Unit: tasks/second Data Source: ThreadPoolExecutor#getCompletedTaskCount()","title":"threadpool.completedTaskCount"},{"location":"ext/thread-pools/#threadpoolcurrentthreadsbusy","text":"Gauge showing the current number of threads actively doing work. Unit: count Data Source: ThreadPoolExecutor#getActiveCount()","title":"threadpool.currentThreadsBusy"},{"location":"ext/thread-pools/#threadpoolmaxthreads","text":"Gauge showing the current maximum number of threads configured for the pool. Unit: count Data Source: ThreadPoolExecutor#getMaximumPoolSize()","title":"threadpool.maxThreads"},{"location":"ext/thread-pools/#threadpoolpoolsize","text":"Gauge showing the current size of the pool. Unit: count Data Source: ThreadPoolExecutor#getPoolSize()","title":"threadpool.poolSize"},{"location":"ext/thread-pools/#threadpoolcorepoolsize","text":"Gauge showing the current maximum number of core threads configured for the pool. Unit: count Data Source: ThreadPoolExecutor#getCorePoolSize()","title":"threadpool.corePoolSize"},{"location":"ext/thread-pools/#threadpoolqueuesize","text":"Gauge showing the current number of threads queued for execution. Unit: count Data Source: ThreadPoolExecutor#getQueue().size()","title":"threadpool.queueSize"},{"location":"intro/clock/","text":"Clock When taking measurements or working with timers it is recommended to use the clock interface. It provides two methods for measuring time: Wall Time This is what most users think of for time. It can be used to get the current time like what you would see on a wall clock. In most cases when not running in tests this will call System.currentTimeMillis() . Note that the values returned by this method may not be monontonically increasing. Just like a clock on your wall, this value can go back in time or jump forward at unpredictable intervals if someone sets the time. On many systems ntpd will be constantly keeping the time synced up with an authoritative source. With spectator, the clock is typically accessed via the regstry . Example of usage: // Current time in milliseconds since the epoch long currentTime = registry . clock (). wallTime (); Monotonic Time While it is good in general for the wall clock to show the correct time, the unpredictable changes mean it is not a good choice for measuring how long an operation took. Consider a simple example of measuring request latency on a server: long start = registry . clock (). wallTime (); handleRequest ( request , response ); long end = registry . clock (). wallTime (); reqLatencyTimer . record ( end - start , TimeUnit . MILLISECONDS ); If ntp fixes the server time between start and end , then the recorded latency will be wrong. Spectator will protect against obviously wrong measurements like negative latencies by dropping those values when they are recorded. However, the change could incorrectly shorten or lengthen the measured latency. The clock interface also provides access to a monotonic source that is only useful for measuring elapsed time, for example: long start = registry . clock (). monotonicTime (); handleRequest ( request , response ); long end = registry . clock (). monotonicTime (); reqLatencyTimer . record ( end - start , TimeUnit . NANOSECONDS ); In most cases this will map to System.nanoTime() . Note the actual value returned is not meaningful unless compared with another sample to get a delta. Manual Clock If timing code is written to the clock interface, then alternative implemenations can be plugged in. For test cases it is common to use ManualClock so that tests can be reliable and fast without having to rely on hacks like sleep or assuming something will run in less than a certain amount of time. ManualClock clock = new ManualClock (); Registry registry = new DefaultRegistry ( clock ); Timer timer = registry . timer ( test ); timer . record (() - { doSomething (); clock . setMonotonicTime ( 42L ); }); Assert . assertEquals ( timer . totalTime (), 42L );","title":"Clock"},{"location":"intro/clock/#clock","text":"When taking measurements or working with timers it is recommended to use the clock interface. It provides two methods for measuring time:","title":"Clock"},{"location":"intro/clock/#wall-time","text":"This is what most users think of for time. It can be used to get the current time like what you would see on a wall clock. In most cases when not running in tests this will call System.currentTimeMillis() . Note that the values returned by this method may not be monontonically increasing. Just like a clock on your wall, this value can go back in time or jump forward at unpredictable intervals if someone sets the time. On many systems ntpd will be constantly keeping the time synced up with an authoritative source. With spectator, the clock is typically accessed via the regstry . Example of usage: // Current time in milliseconds since the epoch long currentTime = registry . clock (). wallTime ();","title":"Wall Time"},{"location":"intro/clock/#monotonic-time","text":"While it is good in general for the wall clock to show the correct time, the unpredictable changes mean it is not a good choice for measuring how long an operation took. Consider a simple example of measuring request latency on a server: long start = registry . clock (). wallTime (); handleRequest ( request , response ); long end = registry . clock (). wallTime (); reqLatencyTimer . record ( end - start , TimeUnit . MILLISECONDS ); If ntp fixes the server time between start and end , then the recorded latency will be wrong. Spectator will protect against obviously wrong measurements like negative latencies by dropping those values when they are recorded. However, the change could incorrectly shorten or lengthen the measured latency. The clock interface also provides access to a monotonic source that is only useful for measuring elapsed time, for example: long start = registry . clock (). monotonicTime (); handleRequest ( request , response ); long end = registry . clock (). monotonicTime (); reqLatencyTimer . record ( end - start , TimeUnit . NANOSECONDS ); In most cases this will map to System.nanoTime() . Note the actual value returned is not meaningful unless compared with another sample to get a delta.","title":"Monotonic Time"},{"location":"intro/clock/#manual-clock","text":"If timing code is written to the clock interface, then alternative implemenations can be plugged in. For test cases it is common to use ManualClock so that tests can be reliable and fast without having to rely on hacks like sleep or assuming something will run in less than a certain amount of time. ManualClock clock = new ManualClock (); Registry registry = new DefaultRegistry ( clock ); Timer timer = registry . timer ( test ); timer . record (() - { doSomething (); clock . setMonotonicTime ( 42L ); }); Assert . assertEquals ( timer . totalTime (), 42L );","title":"Manual Clock"},{"location":"intro/conventions/","text":"Quick summary: Names Describe the measurement being collected Use camel case Static Succinct Tags Should be used for dimensional drill-down Be careful about combinatorial explosion Tag keys should be static Use id to distinguish between instances Use base units Names Describe the measurement Use camel case The main goal here is to promote consistency which makes it easier for users. The choice of style is somewhat arbitrary, camel case was chosen because: Used by snmp Used by java It was the most common in use at Netflix when this guideline was added The exception to this rule is where there is an established common case. For example with Amazon regions it is preferred to use us-east-1 rather than usEast1 as it is the more common form. Static There shouldn't be any dynamic content that goes into a metric name. Metric names and associated tag keys are how users will interact with the data being produced. Succinct Long names should be avoided. Tags Historically tags have been used to play one of two roles: Dimensions : dimensions are the primary use and it allows the data to be sliced and diced so it is possible to drill down into the data. Namespace : similar to packages in Java in this mode it would be used to group related data. This type of usage is discouraged. As a general rule it should be possible to use the name as a pivot. This means that if just the name is selected, then the user can drill down using other dimensions and be able to reason about the value being shown. As a concrete example, suppose we have two metrics: The number of threads currently in a thread pool. The number of rows in a database table. Bad approach Id poolSize = registry . createId ( size ) . withTag ( class , ThreadPool ) . withTag ( id , server-requests ); Id poolSize = registry . createId ( size ) . withTag ( class , Database ) . withTag ( table , users ); In this approach, if I select the name, size , it will match both the version for ThreadPool and Database classes. So you would get a value that is the an aggregate of the number of threads and the number of items in a database. Recommended Id poolSize = registry . createId ( threadpool.size ) . withTag ( id , server-requests ); Id poolSize = registry . createId ( db.size ) . withTag ( table , users ); This variant provides enough context so that if just the name is selected the value can be reasoned about and is at least potentially meaningful. For example if I select threadpool.size I can see the total number of threads in all pools. Then I can group by or select an id to drill down further. Use base units Keep measurements in base units where possible. For example I would rather have all timers in seconds, disk sizes should be bytes, or network rates should be bytes/second. The reason is that for my uses this usually means the unit is obvious from the name. It also means the SI prefix shown on the graph images make more sense, e.g. 1k is 1 kilobyte not 1 kilo-megabyte.","title":"Naming Conventions"},{"location":"intro/conventions/#names","text":"","title":"Names"},{"location":"intro/conventions/#describe-the-measurement","text":"","title":"Describe the measurement"},{"location":"intro/conventions/#use-camel-case","text":"The main goal here is to promote consistency which makes it easier for users. The choice of style is somewhat arbitrary, camel case was chosen because: Used by snmp Used by java It was the most common in use at Netflix when this guideline was added The exception to this rule is where there is an established common case. For example with Amazon regions it is preferred to use us-east-1 rather than usEast1 as it is the more common form.","title":"Use camel case"},{"location":"intro/conventions/#static","text":"There shouldn't be any dynamic content that goes into a metric name. Metric names and associated tag keys are how users will interact with the data being produced.","title":"Static"},{"location":"intro/conventions/#succinct","text":"Long names should be avoided.","title":"Succinct"},{"location":"intro/conventions/#tags","text":"Historically tags have been used to play one of two roles: Dimensions : dimensions are the primary use and it allows the data to be sliced and diced so it is possible to drill down into the data. Namespace : similar to packages in Java in this mode it would be used to group related data. This type of usage is discouraged. As a general rule it should be possible to use the name as a pivot. This means that if just the name is selected, then the user can drill down using other dimensions and be able to reason about the value being shown. As a concrete example, suppose we have two metrics: The number of threads currently in a thread pool. The number of rows in a database table.","title":"Tags"},{"location":"intro/conventions/#bad-approach","text":"Id poolSize = registry . createId ( size ) . withTag ( class , ThreadPool ) . withTag ( id , server-requests ); Id poolSize = registry . createId ( size ) . withTag ( class , Database ) . withTag ( table , users ); In this approach, if I select the name, size , it will match both the version for ThreadPool and Database classes. So you would get a value that is the an aggregate of the number of threads and the number of items in a database.","title":"Bad approach"},{"location":"intro/conventions/#recommended","text":"Id poolSize = registry . createId ( threadpool.size ) . withTag ( id , server-requests ); Id poolSize = registry . createId ( db.size ) . withTag ( table , users ); This variant provides enough context so that if just the name is selected the value can be reasoned about and is at least potentially meaningful. For example if I select threadpool.size I can see the total number of threads in all pools. Then I can group by or select an id to drill down further.","title":"Recommended"},{"location":"intro/conventions/#use-base-units","text":"Keep measurements in base units where possible. For example I would rather have all timers in seconds, disk sizes should be bytes, or network rates should be bytes/second. The reason is that for my uses this usually means the unit is obvious from the name. It also means the SI prefix shown on the graph images make more sense, e.g. 1k is 1 kilobyte not 1 kilo-megabyte.","title":"Use base units"},{"location":"intro/counter/","text":"Counters A counter is used to measure the rate at which some event is occurring. Consider a simple queue, counters would be used to measure things like the rate at which items are being inserted and removed. Counters are created using the registry which will be setup as part of application initialization. For example: public class Queue { private final Counter insertCounter ; private final Counter removeCounter ; private final QueueImpl impl ; @Inject public Queue ( Registry registry ) { insertCounter = registry . counter ( queue.insert ); removeCounter = registry . counter ( queue.remove ); impl = new QueueImpl (); } Then call increment when an event occurs: public void insert ( Object obj ) { insertCounter . increment (); impl . insert ( obj ); } public Object remove () { if ( impl . nonEmpty ()) { removeCounter . increment (); return impl . remove (); } else { return null ; } } Optionally an amount can be passed in when calling increment. This is useful when a collection of events happens together. public void insertAll ( Collection Object objs ) { insertCounter . increment ( objs . size ()); impl . insertAll ( objs ); } }","title":"Counters"},{"location":"intro/counter/#counters","text":"A counter is used to measure the rate at which some event is occurring. Consider a simple queue, counters would be used to measure things like the rate at which items are being inserted and removed. Counters are created using the registry which will be setup as part of application initialization. For example: public class Queue { private final Counter insertCounter ; private final Counter removeCounter ; private final QueueImpl impl ; @Inject public Queue ( Registry registry ) { insertCounter = registry . counter ( queue.insert ); removeCounter = registry . counter ( queue.remove ); impl = new QueueImpl (); } Then call increment when an event occurs: public void insert ( Object obj ) { insertCounter . increment (); impl . insert ( obj ); } public Object remove () { if ( impl . nonEmpty ()) { removeCounter . increment (); return impl . remove (); } else { return null ; } } Optionally an amount can be passed in when calling increment. This is useful when a collection of events happens together. public void insertAll ( Collection Object objs ) { insertCounter . increment ( objs . size ()); impl . insertAll ( objs ); } }","title":"Counters"},{"location":"intro/dist-summary/","text":"Distribution Summaries A distribution summary is used to track the distribution of events. It is similar to a timer, but more general in that the size does not have to be a period of time. For example, a distribution summary could be used to measure the payload sizes of requests hitting a server. It is recommended to always use base units when recording the data. So if measuring the payload size use bytes, not kilobytes or some other unit. Distribution summaries are created using the registry which will be setup as part of application initialization. For example: public class Server { private final DistributionSummary requestSize ; @Inject public Server ( Registry registry ) { requestSize = registry . distributionSummary ( server.requestSize ); } Then call record when an event occurs: public Response handle ( Request request ) { requestSize . record ( request . sizeInBytes ()); } }","title":"Distribution Summaries"},{"location":"intro/dist-summary/#distribution-summaries","text":"A distribution summary is used to track the distribution of events. It is similar to a timer, but more general in that the size does not have to be a period of time. For example, a distribution summary could be used to measure the payload sizes of requests hitting a server. It is recommended to always use base units when recording the data. So if measuring the payload size use bytes, not kilobytes or some other unit. Distribution summaries are created using the registry which will be setup as part of application initialization. For example: public class Server { private final DistributionSummary requestSize ; @Inject public Server ( Registry registry ) { requestSize = registry . distributionSummary ( server.requestSize ); } Then call record when an event occurs: public Response handle ( Request request ) { requestSize . record ( request . sizeInBytes ()); } }","title":"Distribution Summaries"},{"location":"intro/gauge/","text":"Gauges A gauge is a value that is sampled at some point in time. Typical examples for gauges would be the size of a queue or number of threads in the running state. Since gauges are not updated inline when a state change occurs, there is no information about what might have occurred between samples. Consider monitoring the behavior of a queue of tasks. If the data is being collected once a minute, then a gauge for the size will show the size when it was sampled. The size may have been much higher or lower at some point during interval, but that is not known. Polled Gauges The most common use of gauges is by registering a hook with Spectator so that it will poll the values in the background. This is done by using the PolledMeter helper class. A polled gauge is registered by passing in an id, a reference to the object, and a function to get or compute a numeric value based on the object. Note that a gauge should only be registered once, not on each update. Consider this example of a web server tracking the number of connections: class HttpServer { // Tracks the number of current connections to the server private AtomicInteger numConnections ; public HttpServer ( Registry registry ) { numConnections = PolledMeter . using ( registry ) . withName ( server.numConnections ) . monitorValue ( new AtomicInteger ( 0 )); } public void onConnectionCreated () { numConnections . incrementAndGet (); ... } public void onConnectionClosed () { numConnections . decrementAndGet (); ... } ... } The spectator registry will keep a weak reference to the object. If the object is garbage collected, then it will automatically drop the registration. In the example above, the registry will have a weak reference to numConnections and the server instance will have a strong reference to numConnections . If the server instance goes away, then the gauge will as well. When multiple gauges are registered with the same id the reported value will be the sum of the matches. For example, if multiple instances of the HttpServer class were created on different ports, then the value server.numConnections would be the total number of connections across all server instances. If a different behavior is desired, then ensure your usage does not perform multiple registrations. There are several different ways to register a gauge: Using Number A gauge can also be created based on an implementation of Number. Note the number implementation should be thread safe. For example: AtomicInteger size = new AtomicInteger (); PolledMeter . using ( registry ) . withName ( queue.size ) . monitorValue ( size ); The call will return the Number so the registration can be inline on the assignment: AtomicInteger size = PolledMeter . using ( registry ) . withName ( queue.size ) . monitorValue ( new AtomicInteger ()); Updates to the value are preformed by updating the number instance directly. Using Lambda Specify a lambda that takes the object as parameter. public class Queue { @Inject public Queue ( Registry registry ) { PolledMeter . using ( registry ) . withName ( queue.size ) . monitorValue ( this , Queue :: size ); } ... } Warning Be careful to avoid creating a reference to the object in the lambda. It will prevent garbage collection and can lead to a memory leak in the application. For example, by calling size without using the passed in object there will be a reference to this : PolledMeter.using(registry).withName(\"queue.size\").monitorValue(this, obj - size()); Collection Sizes For classes that implement Collection or Map there are helpers: Queue queue = new LinkedBlockingQueue (); PolledMeter . using ( registry ) . withName ( queue.size ) . monitorSize ( queue ); Map String , String cache = new ConcurrentMap (); PolledMeter . using ( registry ) . withName ( cache.size ) . monitorSize ( cache ); Monotonic Counters A common technique used by some libraries is to expose a monotonically increasing counter that represents the number of events since the system was initialized. An example of that in the JDK is ThreadPoolExecutor.getCompletedTaskCount() which returns the number of completed tasks on the thread pool. For sources like this the monitorMonotonicCounter method can be used: // For an implementation of Number LongAdder tasks = new LongAdder (); PolledMeter . using ( registry ) . withName ( pool.completedTasks ) . monitorMonotonicCounter ( tasks ); // Or using a lambda ThreadPoolExecutor executor = ... PolledMeter . using ( registry ) . withName ( pool.completedTasks ) . monitorMonotonicCounter ( executor , ThreadPoolExecutor :: getCompletedTaskCount ); For thread pools specifically, there are better options for getting standard metrics. See the docs for the Thread Pools extension for more information. Active Gauges Gauges can also be set directly by the user. In this mode the user is responsible for regularly updating the value of the gauge by calling set. Looking at the HttpServer example, with an active gauge it would look like: class HttpServer { // Tracks the number of current connections to the server private AtomicInteger numConnections ; private Gauge gauge ; public HttpServer ( Registry registry ) { numConnections = new AtomicInteger (); gauge = registry . gauge ( server.numConnections ); gauge . set ( numConnections . get ()); } public void onConnectionCreated () { numConnections . incrementAndGet (); gauge . set ( numConnections . get ()); ... } public void onConnectionClosed () { numConnections . decrementAndGet (); gauge . set ( numConnections . get ()); ... } ... }","title":"Gauges"},{"location":"intro/gauge/#gauges","text":"A gauge is a value that is sampled at some point in time. Typical examples for gauges would be the size of a queue or number of threads in the running state. Since gauges are not updated inline when a state change occurs, there is no information about what might have occurred between samples. Consider monitoring the behavior of a queue of tasks. If the data is being collected once a minute, then a gauge for the size will show the size when it was sampled. The size may have been much higher or lower at some point during interval, but that is not known.","title":"Gauges"},{"location":"intro/gauge/#polled-gauges","text":"The most common use of gauges is by registering a hook with Spectator so that it will poll the values in the background. This is done by using the PolledMeter helper class. A polled gauge is registered by passing in an id, a reference to the object, and a function to get or compute a numeric value based on the object. Note that a gauge should only be registered once, not on each update. Consider this example of a web server tracking the number of connections: class HttpServer { // Tracks the number of current connections to the server private AtomicInteger numConnections ; public HttpServer ( Registry registry ) { numConnections = PolledMeter . using ( registry ) . withName ( server.numConnections ) . monitorValue ( new AtomicInteger ( 0 )); } public void onConnectionCreated () { numConnections . incrementAndGet (); ... } public void onConnectionClosed () { numConnections . decrementAndGet (); ... } ... } The spectator registry will keep a weak reference to the object. If the object is garbage collected, then it will automatically drop the registration. In the example above, the registry will have a weak reference to numConnections and the server instance will have a strong reference to numConnections . If the server instance goes away, then the gauge will as well. When multiple gauges are registered with the same id the reported value will be the sum of the matches. For example, if multiple instances of the HttpServer class were created on different ports, then the value server.numConnections would be the total number of connections across all server instances. If a different behavior is desired, then ensure your usage does not perform multiple registrations. There are several different ways to register a gauge:","title":"Polled Gauges"},{"location":"intro/gauge/#using-number","text":"A gauge can also be created based on an implementation of Number. Note the number implementation should be thread safe. For example: AtomicInteger size = new AtomicInteger (); PolledMeter . using ( registry ) . withName ( queue.size ) . monitorValue ( size ); The call will return the Number so the registration can be inline on the assignment: AtomicInteger size = PolledMeter . using ( registry ) . withName ( queue.size ) . monitorValue ( new AtomicInteger ()); Updates to the value are preformed by updating the number instance directly.","title":"Using Number"},{"location":"intro/gauge/#using-lambda","text":"Specify a lambda that takes the object as parameter. public class Queue { @Inject public Queue ( Registry registry ) { PolledMeter . using ( registry ) . withName ( queue.size ) . monitorValue ( this , Queue :: size ); } ... } Warning Be careful to avoid creating a reference to the object in the lambda. It will prevent garbage collection and can lead to a memory leak in the application. For example, by calling size without using the passed in object there will be a reference to this : PolledMeter.using(registry).withName(\"queue.size\").monitorValue(this, obj - size());","title":"Using Lambda"},{"location":"intro/gauge/#collection-sizes","text":"For classes that implement Collection or Map there are helpers: Queue queue = new LinkedBlockingQueue (); PolledMeter . using ( registry ) . withName ( queue.size ) . monitorSize ( queue ); Map String , String cache = new ConcurrentMap (); PolledMeter . using ( registry ) . withName ( cache.size ) . monitorSize ( cache );","title":"Collection Sizes"},{"location":"intro/gauge/#monotonic-counters","text":"A common technique used by some libraries is to expose a monotonically increasing counter that represents the number of events since the system was initialized. An example of that in the JDK is ThreadPoolExecutor.getCompletedTaskCount() which returns the number of completed tasks on the thread pool. For sources like this the monitorMonotonicCounter method can be used: // For an implementation of Number LongAdder tasks = new LongAdder (); PolledMeter . using ( registry ) . withName ( pool.completedTasks ) . monitorMonotonicCounter ( tasks ); // Or using a lambda ThreadPoolExecutor executor = ... PolledMeter . using ( registry ) . withName ( pool.completedTasks ) . monitorMonotonicCounter ( executor , ThreadPoolExecutor :: getCompletedTaskCount ); For thread pools specifically, there are better options for getting standard metrics. See the docs for the Thread Pools extension for more information.","title":"Monotonic Counters"},{"location":"intro/gauge/#active-gauges","text":"Gauges can also be set directly by the user. In this mode the user is responsible for regularly updating the value of the gauge by calling set. Looking at the HttpServer example, with an active gauge it would look like: class HttpServer { // Tracks the number of current connections to the server private AtomicInteger numConnections ; private Gauge gauge ; public HttpServer ( Registry registry ) { numConnections = new AtomicInteger (); gauge = registry . gauge ( server.numConnections ); gauge . set ( numConnections . get ()); } public void onConnectionCreated () { numConnections . incrementAndGet (); gauge . set ( numConnections . get ()); ... } public void onConnectionClosed () { numConnections . decrementAndGet (); gauge . set ( numConnections . get ()); ... } ... }","title":"Active Gauges"},{"location":"intro/netflix/","text":"Netflix Integration When running at Netflix, use the atlas-client library to enable transferring the instrumented data to Atlas . See the appropriate section for the type of project you are working on: Libraries Applications , specifically standalone apps using guice or governator directly. Base Server Libraries For libraries, the only dependency that should be needed is: com.netflix.spectator:spectator-api:0.83.0 The bindings to integrate internally should be included with the application. In your code, just inject a registry, e.g.: public class Foo { @Inject public Foo ( Registry registry ) { ... } ... } See the testing docs for more information about creating a binding to use with tests. Libraries should not install SpectatorModule . The bindings to use for the registry should be determined by the application that is using the library. Think of it as being like slf4j where logging configuration is up to the end-user, not the library owner. When creating a Guice module for your library, you may want to avoid binding errors if the end-user has not provided a binding for the Spectator registry. This can be done by using optional injections inside of the module, for example: // Sample library class public class MyLib { Registry registry ; @Inject public MyLib ( Registry registry ) { this . registry = registry ; } } // Guice module to configure the library and setup the bindings public class MyLibModule extends AbstractModule { private static final Logger LOGGER = LoggerFactory . getLogger ( MyLibModule . class ); @Override protected void configure () { } @Provides private MyLib provideMyLib ( OptionalInjections opts ) { return new MyLib ( opts . registry ()); } private static class OptionalInjections { @Inject ( optional = true ) private Registry registry ; Registry registry () { if ( registry == null ) { LOGGER . warn ( no spectator registry has been bound, so using noop implementation ); registry = new NoopRegistry (); } return registry ; } } } Applications Application should include a dependency on the atlas-client plugin: netflix : atlas - client : latest . release Note this is an internal only library with configs specific to the Netflix environments. It is assumed you are using Nebula so that internal maven repositories are available for your build. When configuring with governator specify the AtlasModule : Injector injector = LifecycleInjector . builder () . withModules ( new AtlasModule ()) . build () . createInjector (); The registry binding will then be available so it can be injected as shown in the libraries section . The insight libraries do not use any governator or guice specific features. So it is possible to use guice or other dependency injection frameworks directly with the following caveats: However, some of the libraries do use the @PostConstruct and @PreDestroy annotations for managing lifecycle. Governator adds lifecycle management and many other features on top of guice and is the recommended way. For more minimalist support of just the lifecycle annotations on top of guice see iep-guice . The bindings and configuration necessary to run correctly with the internal setup are only supported as guice modules. If trying to use some other dependency injection framework, then you will be responsible for either finding a way to leverage the guice module in that framework or recreating those bindings and maintaining them as things change. It is not a paved road path. Base Server If using base-server , then you will get the Spectator and Atlas bindings automatically. Auto Plugin Warning Deprecated : Use of AutoBindSingleton is generally discouraged. It is recommended to use one of the other methods. If you are only interested in getting the GC logging, there is a library with an auto-bind singleton that can be used: com.netflix.spectator:spectator-nflx:0.83.0 Assuming you are using karyon/base-server or governator with com.netflix in the list of base packages then the plugin should get automatically loaded.","title":"Netflix Integration"},{"location":"intro/netflix/#netflix-integration","text":"When running at Netflix, use the atlas-client library to enable transferring the instrumented data to Atlas . See the appropriate section for the type of project you are working on: Libraries Applications , specifically standalone apps using guice or governator directly. Base Server","title":"Netflix Integration"},{"location":"intro/netflix/#libraries","text":"For libraries, the only dependency that should be needed is: com.netflix.spectator:spectator-api:0.83.0 The bindings to integrate internally should be included with the application. In your code, just inject a registry, e.g.: public class Foo { @Inject public Foo ( Registry registry ) { ... } ... } See the testing docs for more information about creating a binding to use with tests. Libraries should not install SpectatorModule . The bindings to use for the registry should be determined by the application that is using the library. Think of it as being like slf4j where logging configuration is up to the end-user, not the library owner. When creating a Guice module for your library, you may want to avoid binding errors if the end-user has not provided a binding for the Spectator registry. This can be done by using optional injections inside of the module, for example: // Sample library class public class MyLib { Registry registry ; @Inject public MyLib ( Registry registry ) { this . registry = registry ; } } // Guice module to configure the library and setup the bindings public class MyLibModule extends AbstractModule { private static final Logger LOGGER = LoggerFactory . getLogger ( MyLibModule . class ); @Override protected void configure () { } @Provides private MyLib provideMyLib ( OptionalInjections opts ) { return new MyLib ( opts . registry ()); } private static class OptionalInjections { @Inject ( optional = true ) private Registry registry ; Registry registry () { if ( registry == null ) { LOGGER . warn ( no spectator registry has been bound, so using noop implementation ); registry = new NoopRegistry (); } return registry ; } } }","title":"Libraries"},{"location":"intro/netflix/#applications","text":"Application should include a dependency on the atlas-client plugin: netflix : atlas - client : latest . release Note this is an internal only library with configs specific to the Netflix environments. It is assumed you are using Nebula so that internal maven repositories are available for your build. When configuring with governator specify the AtlasModule : Injector injector = LifecycleInjector . builder () . withModules ( new AtlasModule ()) . build () . createInjector (); The registry binding will then be available so it can be injected as shown in the libraries section . The insight libraries do not use any governator or guice specific features. So it is possible to use guice or other dependency injection frameworks directly with the following caveats: However, some of the libraries do use the @PostConstruct and @PreDestroy annotations for managing lifecycle. Governator adds lifecycle management and many other features on top of guice and is the recommended way. For more minimalist support of just the lifecycle annotations on top of guice see iep-guice . The bindings and configuration necessary to run correctly with the internal setup are only supported as guice modules. If trying to use some other dependency injection framework, then you will be responsible for either finding a way to leverage the guice module in that framework or recreating those bindings and maintaining them as things change. It is not a paved road path.","title":"Applications"},{"location":"intro/netflix/#base-server","text":"If using base-server , then you will get the Spectator and Atlas bindings automatically.","title":"Base Server"},{"location":"intro/netflix/#auto-plugin","text":"Warning Deprecated : Use of AutoBindSingleton is generally discouraged. It is recommended to use one of the other methods. If you are only interested in getting the GC logging, there is a library with an auto-bind singleton that can be used: com.netflix.spectator:spectator-nflx:0.83.0 Assuming you are using karyon/base-server or governator with com.netflix in the list of base packages then the plugin should get automatically loaded.","title":"Auto Plugin"},{"location":"intro/registry/","text":"Registry There are a few basic concepts you need to learn to use Spectator. The registry is the main class for managing a set of meters. A meter is a class for collecting a set of measurements about your application. Choosing an Implementation The core spectator library, spectator-api , comes with the following registry implementations: Class Dependency Description DefaultRegistry spectator-api Updates local counters, frequently used with unit tests . NoopRegistry spectator-api Does nothing, tries to make operations as cheap as possible. This implementation is typically used to help understand the overhead being created due to instrumentation. It can also be useful in testing to help ensure that no side effects were introduced where the instrumentation is now needed in order for the application for function properly. ServoRegistry spectator-reg-servo Map to servo library . ServoRegistry is deprecated; consider use of another implementation. MetricsRegistry spectator-reg-metrics3 Map to metrics3 library . This implementation is typically used for reporting to local files, JMX, or other backends like Graphite. Note that it uses a hierarchical naming scheme rather than the dimensional naming used by Spectator, so the names will get flattened when mapped to this registry. It is recommended for libraries to write code against the Registry interface and allow the implementation to get injected by the user of the library. The simplest way is to accept the registry via the constructor, for example: public class HttpServer { public HttpServer ( Registry registry ) { // use registry to collect measurements } } The user of the class can then provide the implementation: Registry registry = new DefaultRegistry (); HttpServer server = new HttpServer ( registry ); More complete examples can be found on the testing page or in the spectator-examples repo . Working With Ids Spectator is primarily intended for collecting data for dimensional time series backends like Atlas . The ids used for looking up a meter in the registry consist of a name and set of tags. Ids will be consumed many times by users after the data has been reported so they should be chosen with some care and thought about how they will get used. See the conventions page for some general guidelines. Ids are created via the registry, for example: Id id = registry . createId ( server.requestCount ); The ids are immutable so they can be freely passed around and used in a concurrent context. Tags can be added when an id is created: Id id = registry . createId ( server.requestCount , status , 2xx , method , GET ); Or by using withTag and withTags on an existing id: public class HttpServer { private final Id baseId ; public HttpServer ( Registry registry ) { baseId = registry . createId ( server.requestCount ); } private void handleRequestComplete ( HttpRequest req , HttpResponse res ) { // Remember Id is immutable, withTags will return a copy with the // the additional metadata Id reqId = baseId . withTags ( status , res . getStatus (), method , req . getMethod (). name ()); registry . counter ( reqId ). increment (); } private void handleRequestError ( HttpRequest req , Throwable t ) { // Can also be added individually using `withTag`. However, it is better // for performance to batch modifications using `withTags`. Id reqId = baseId . withTag ( error , t . getClass (). getSimpleName ()) . withTag ( method , req . getMethod (). name ()); registry . counter ( reqId ). increment (); } } Collecting Measurements Once you have an id, the registry can be used to get an instance of a meter to record a measurement. Meters can roughly be categorized in two groups: Active Active meters are ones that are called directly when some event occurs. There are three basic types supported: Counters : measures how often something is occuring. This will be reported to backend systems as a rate per second. For example, number of requests processed by web server. Timers : measures how long something took. For example, latency of requests processed by a web server. Distribution Summaries : measures the size of something. For example, entity sizes for requests processed by a web server. Passive Passive meters are ones where the registry just has a reference to get the value when needed. For example, the number of current connections on a web server or the number threads that are currently in use. These will be gauges . Global Registry There are some use-cases where injecting the registry is not possible or is too cumbersome. The main example from the core spectator libraries is the log4j appender . The global registry is useful there because logging is often initialized before any other systems and Spectator itself uses logging via the slf4j api which is quite likely being bound to log4j when that the appender is being used. By using the global registry the logging initialization can proceed before the spectator initialization in the application. Though any measurements taken before a registry instance has been added will be lost. The global registry is accessed using: Registry registry = Spectator . globalRegistry (); By default it will not record anything. For a specific registry instance you can choose to configure it to work with the global registry by calling add : public void init () { Registry registry = // Choose an appropriate implementation // Add it to the global registry so it will receive // any activity on the global registry Spectator . globalRegistry (). add ( registry ); } Any measurements taken while no registries are added to the global instance will be lost. If multiple registries are added, all will recieve updates made to the global registry.","title":"Registry"},{"location":"intro/registry/#registry","text":"There are a few basic concepts you need to learn to use Spectator. The registry is the main class for managing a set of meters. A meter is a class for collecting a set of measurements about your application.","title":"Registry"},{"location":"intro/registry/#choosing-an-implementation","text":"The core spectator library, spectator-api , comes with the following registry implementations: Class Dependency Description DefaultRegistry spectator-api Updates local counters, frequently used with unit tests . NoopRegistry spectator-api Does nothing, tries to make operations as cheap as possible. This implementation is typically used to help understand the overhead being created due to instrumentation. It can also be useful in testing to help ensure that no side effects were introduced where the instrumentation is now needed in order for the application for function properly. ServoRegistry spectator-reg-servo Map to servo library . ServoRegistry is deprecated; consider use of another implementation. MetricsRegistry spectator-reg-metrics3 Map to metrics3 library . This implementation is typically used for reporting to local files, JMX, or other backends like Graphite. Note that it uses a hierarchical naming scheme rather than the dimensional naming used by Spectator, so the names will get flattened when mapped to this registry. It is recommended for libraries to write code against the Registry interface and allow the implementation to get injected by the user of the library. The simplest way is to accept the registry via the constructor, for example: public class HttpServer { public HttpServer ( Registry registry ) { // use registry to collect measurements } } The user of the class can then provide the implementation: Registry registry = new DefaultRegistry (); HttpServer server = new HttpServer ( registry ); More complete examples can be found on the testing page or in the spectator-examples repo .","title":"Choosing an Implementation"},{"location":"intro/registry/#working-with-ids","text":"Spectator is primarily intended for collecting data for dimensional time series backends like Atlas . The ids used for looking up a meter in the registry consist of a name and set of tags. Ids will be consumed many times by users after the data has been reported so they should be chosen with some care and thought about how they will get used. See the conventions page for some general guidelines. Ids are created via the registry, for example: Id id = registry . createId ( server.requestCount ); The ids are immutable so they can be freely passed around and used in a concurrent context. Tags can be added when an id is created: Id id = registry . createId ( server.requestCount , status , 2xx , method , GET ); Or by using withTag and withTags on an existing id: public class HttpServer { private final Id baseId ; public HttpServer ( Registry registry ) { baseId = registry . createId ( server.requestCount ); } private void handleRequestComplete ( HttpRequest req , HttpResponse res ) { // Remember Id is immutable, withTags will return a copy with the // the additional metadata Id reqId = baseId . withTags ( status , res . getStatus (), method , req . getMethod (). name ()); registry . counter ( reqId ). increment (); } private void handleRequestError ( HttpRequest req , Throwable t ) { // Can also be added individually using `withTag`. However, it is better // for performance to batch modifications using `withTags`. Id reqId = baseId . withTag ( error , t . getClass (). getSimpleName ()) . withTag ( method , req . getMethod (). name ()); registry . counter ( reqId ). increment (); } }","title":"Working With Ids"},{"location":"intro/registry/#collecting-measurements","text":"Once you have an id, the registry can be used to get an instance of a meter to record a measurement. Meters can roughly be categorized in two groups:","title":"Collecting Measurements"},{"location":"intro/registry/#active","text":"Active meters are ones that are called directly when some event occurs. There are three basic types supported: Counters : measures how often something is occuring. This will be reported to backend systems as a rate per second. For example, number of requests processed by web server. Timers : measures how long something took. For example, latency of requests processed by a web server. Distribution Summaries : measures the size of something. For example, entity sizes for requests processed by a web server.","title":"Active"},{"location":"intro/registry/#passive","text":"Passive meters are ones where the registry just has a reference to get the value when needed. For example, the number of current connections on a web server or the number threads that are currently in use. These will be gauges .","title":"Passive"},{"location":"intro/registry/#global-registry","text":"There are some use-cases where injecting the registry is not possible or is too cumbersome. The main example from the core spectator libraries is the log4j appender . The global registry is useful there because logging is often initialized before any other systems and Spectator itself uses logging via the slf4j api which is quite likely being bound to log4j when that the appender is being used. By using the global registry the logging initialization can proceed before the spectator initialization in the application. Though any measurements taken before a registry instance has been added will be lost. The global registry is accessed using: Registry registry = Spectator . globalRegistry (); By default it will not record anything. For a specific registry instance you can choose to configure it to work with the global registry by calling add : public void init () { Registry registry = // Choose an appropriate implementation // Add it to the global registry so it will receive // any activity on the global registry Spectator . globalRegistry (). add ( registry ); } Any measurements taken while no registries are added to the global instance will be lost. If multiple registries are added, all will recieve updates made to the global registry.","title":"Global Registry"},{"location":"intro/servo-comparison/","text":"Servo Comparison Servo is an alternative client monitoring library that is also developed by Netflix. Originally spectator was an experiment for a simpler API that wrapped servo. It was done as a separate project to avoid breaking backwards compatibility for servo. From a user perspective, both will be supported for a long time, but most of our efforts for future improvement will go to spectator. For new code it is recommended to use the spectator API. If running at Netflix the correct bindings will be in place for both servo and spectator. Differences This section provides a quick summary of the differences. Simpler API Servo gives the user a lot of control, but this makes it hard to use correctly. For example, to create a counter the user needs to understand the tradeoffs and choose between: BasicCounter DynamicCounter ContextualCounter StepCounter Further each of these can impact how data is reported to observers. The spectator API focuses on the constructs a user needs to instrument the code. In spectator the user would always use the registry to create a Counter . The implementation details are left up to the registry. The registration is simpler as well to avoid common pitfalls when using servo like overwriting a registered object. More Focused The goal of spectator is instrumenting code to send to a dimensional time-series system like Atlas . Servo has goals of staying compatible with a number of legacy libraries and naming formats, exposing data to JMX, etc. Examples of how this influences decisions: No support for non-numeric data. Servo supported this for exposing to JMX. Exposing the numeric data registered in spectator to JMX can be done using a registry that supports it, but there is no goal to be a general interface for exposing arbitrary data in JMX. No support for customizeable time units when reporting timer data. Base units should always be used for reporting and conversions can be performed in the presentation layer if needed. It also avoids a lot of the confusion around the timer unit for the data and issues like creating aggregates that are meaningless because of mixed units. It is better to have a simple way to get correct and easy to reason about data to the backend than many options. If you want more knobs, then you can use Servo. DI Friendly When servo was originally written dependency injection was not heavily used at Netflix. Further servo needed to stay compatible with a number of use-cases that were heavily static. While spectator does have a static registry that can be used, the recommended way is to create a registry and inject it either manually or via a framework into the classes that need it. This also makes it much easier to test in isolation . Migration If you want to migrate from the servo API to the spectator API, then this section provides some guides on how servo constructs can be ported over. The sub-sections are the class names of monitor types supported by servo. For users at Netflix, note we are not actively pushing teams to migrate or do any additional work. Servo is still supported and if it works for your use-cases feel free to continue using it. Registration First read through the servo docs on registration . In servo if you have a class like: public class Foo { private AtomicInteger gauge ; private Counter counter ; public Foo ( String id ) { gauge = new AtomicInteger (); counter = new BasicCounter ( MonitorConfig . builder ( counter ). build ()); Monitors . registerObject ( id , this ); } @Monitor ( name = gauge , type = DataSourceType . GAUGE ) private int gauge () { return gauge . get (); } public void doSomething () { ... } } The state of the class is in the member variables of an instance of Foo . If multiple instances of class Foo are created with the same value for id , then the last one will overwrite the others for the registration. So the values getting reported will only be from the last instance registered. Also the registry has a reference to the instance of Foo so it will never go away. For counters and timers one way to get around this is to use DynamicCounter and DynamicTimer respectively. Those classes will automatically handle the registration and expire if there is no activity. They also get used for cases where the set of dimensions is not known up front. Gauges need to sample the state of something so they need to have a reference to an object that contains the state. So the user would need to ensure that only a single copy was registered leading to patterns like: class Foo { private static class FooStats { private AtomicInteger gauge ; private Counter counter ; public FooStats ( String id ) { gauge = new AtomicInteger (); counter = new BasicCounter ( MonitorConfig . builder ( counter ). build ()); Monitors . registerObject ( id , this ); } @Monitor ( name = gauge , type = DataSourceType . GAUGE ) private int gauge () { return gauge . get (); } } private static ConcurrentHashMap String , FooStats STATS = new ConcurrentHashMap (); private final FooStats stats ; public Foo ( String id ) { stats = STATS . computeIfAbsent ( id , ( i ) - new FooStats ( i )); } public void doSomething () { ... stats . update (); } } This ensures that there is a single copy for a given id. In spectator this example would look like: public class Foo { private AtomicInteger gauge ; private Counter counter ; public Foo ( Registry registry , String id ) { Id gaugeId = registry . createId ( gauge ). withTag ( id , id ); gauge = registry . gauge ( gaugeId , new AtomicInteger ()); counter = registry . counter ( counter , id , id ); } public void doSomething () { ... } } Everything using the same registry will get the same counter instance if the same id is used. For the gauge the registry will keep a weak reference and will sum the values if multiple instances are present. Since it is a weak reference, nothing will prevent an instance of Foo from getting garbage collected. Annotations Annotations are not supported, use the appropriate meter type: DataSourceType Spectator Alternative COUNTER Counter Usage GAUGE Gauge Usage INFORMATIONAL Not supported BasicCounter See the general overview of registration differences and summary of counter usage . Servo: public class Foo { private final Counter c = new BasicCounter ( MonitorConfig . builder ( name ). build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } public void doSomething () { c . increment (); } } Spectator: public class Foo { private final Counter c ; @Inject public Foo ( Registry registry , String id ) { c = registry . counter ( name , id , id ); } public void doSomething () { c . increment (); } } BasicGauge See the general overview of registration differences and summary of gauge usage . Servo: public class Foo { private final BasicGauge g = new BasicGauge ( MonitorConfig . builder ( name ). build (), this :: getCurrentValue ); public Foo ( String id ) { Monitors . registerObject ( id , this ); } } Spectator: public class Foo { @Inject public Foo ( Registry registry , String id ) { Id gaugeId = registry . createId ( name ). withTag ( id , id ); registry . gauge ( gaugeId , this , Foo :: getCurrentValue ); } } BasicTimer See the general overview of registration differences and summary of timer usage . Note in spectator the reported unit for timers is always seconds and cannot be changed. Seconds is the base unit and other units should only be used as a presentation detail. Servo allows the unit to be customized and defaults to milliseconds. Servo: public class Foo { private final Timer t = new BasicTimer ( MonitorConfig . builder ( name ). build (), TimeUnit . SECONDS ); public Foo ( String id ) { Monitors . registerObject ( id , this ); } public void doSomething () { Stopwatch s = t . start (); try { ... } finally { s . stop (); } } } Spectator: public class Foo { private final Timer t ; @Inject public Foo ( Registry registry , String id ) { t = registry . timer ( name , id , id ); } public void doSomething () { t . record (() - { ... }); } } BasicDistributionSummary See the general overview of registration differences and summary of distribution summary usage . Servo: public class Foo { private final BasicDistributionSummary s = new BasicDistributionSummary ( MonitorConfig . builder ( name ). build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } public void doSomething () { ... s . record ( getValue ()); } } Spectator: public class Foo { private final DistributionSummary s ; @Inject public Foo ( Registry registry , String id ) { s = registry . distributionSummary ( name , id , id ); } public void doSomething () { ... s . record ( getValue ()); } } BasicInformational Not supported, see overview of differences . BasicStopwatch There isn't an explicit stopwatch class in spectator. Just use a timing call directly. Servo: public void doSomething () { Stopwatch s = timer . start (); try { ... } finally { s . stop (); } } Spectator: public void doSomething () { final long s = System . nanoTime (); try { ... } finally { timer . record ( System . nanoTime () - s , TimeUnit . NANOSECONDS ); } } BucketTimer See the general overview of registration differences and summary of sandbox documentation . Note in spectator BucketTimer is provided in the sandbox extension library and may change in future as we gain more experience using it. Servo: public class Foo { private final Timer t = new BucketTimer ( MonitorConfig . builder ( name ). build (), new BucketConfig . Builder () . withTimeUnit ( TimeUnit . MILLISECONDS ) . withBuckets ( new long [] { 500 , 2500 , 5000 , 10000 }) . build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } public void doSomething () { Stopwatch s = t . start (); try { ... } finally { s . stop (); } } } Spectator: public class Foo { private final Timer t ; @Inject public Foo ( Registry registry , String id ) { Id timerId = registry . createId ( name , id , id ); BucketFunction f = BucketFunctions . latency ( 10 , TimeUnit . SECONDS ); t = BucketTimer . get ( registry , timerId , f ); } public void doSomething () { t . record (() - { ... }); } } ContextualCounter Not supported. A fixed tag list for the context is too rigid and this class was never used much at Netflix. Future work being looked at in issue-180 . ContextualTimer Not supported. A fixed tag list for the context is too rigid and this class was never used much at Netflix. Future work being looked at in issue-180 . DoubleGauge See the general overview of registration differences and summary of gauge usage . Servo: public class Foo { private final DoubleGauge g = new DoubleGauge ( MonitorConfig . builder ( name ). build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } } Spectator: import com.google.common.util.concurrent.AtomicDouble ; public class Foo { private final AtomicDouble v ; @Inject public Foo ( Registry registry , String id ) { Id gaugeId = registry . createId ( name ). withTag ( id , id ); v = registry . gauge ( gaugeId , new AtomicDouble ()); } } DurationTimer See the general overview of registration differences and summary of timer usage . Servo: public class Foo { private final DurationTimer t = new DurationTimer ( MonitorConfig . builder ( name ). build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } } Spectator: public class Foo { private final LongTaskTimer t ; @Inject public Foo ( Registry registry , String id ) { t = registry . longTaskTimer ( name , id , id ); } } DynamicCounter See the general overview of registration differences and summary of counter usage . Servo: public class Foo { private final String id ; public Foo ( String id ) { this . id = id ; } public void doSomething ( Context ctxt ) { DynamicCounter . increment ( staticId , id , id ); DynamicCounter . increment ( dynamicId , id , id , foo , ctxt . getFoo ()); } } Spectator: public class Foo { private final Registry registry ; private final String id ; private final Counter staticCounter ; private final Id dynamicId ; @Inject public Foo ( Registry registry , String id ) { this . registry = registry ; this . id = id ; staticCounter = registry . counter ( staticId , id , id ); dynamicId = registry . createId ( dynamicId , id , id ); } public void doSomething ( Context ctxt ) { // Keeping the reference to the counter avoids additional allocations // to create the id object and the lookup cost staticCounter . increment (); // If the id is dynamic it must be looked up registry . counter ( dynamicId , id , id , foo , ctxt . getFoo ()). increment (); // This will update the same counter as the line above, but the base part // of the id is precomputed to make it cheaper to construct the id. registry . counter ( dynamicId . withTag ( foo , ctxt . getFoo ())). increment (); } } DynamicTimer See the general overview of registration differences and summary of timer usage . Servo: public class Foo { private final String id ; private final MonitorConfig staticId ; public Foo ( String id ) { this . id = id ; staticId = MonitorConfig . builder ( staticId ). withTag ( id , id ). build (); } public void doSomething ( Context ctxt ) { final long d = ctxt . getDurationMillis (); DynamicTimer . record ( staticId , TimeUnit . SECONDS , d , TimeUnit . MILLISECONDS ); MonitorConfig dynamicId = MonitorConfig . builder ( dynamicId ) . withTag ( id , id ) . withTag ( foo , ctxt . getFoo ()) . build (); DynamicTimer . record ( dynamicId , TimeUnit . SECONDS , d , TimeUnit . MILLISECONDS ); } } Spectator: public class Foo { private final Registry registry ; private final String id ; private final Timer staticTimer ; private final Id dynamicId ; @Inject public Foo ( Registry registry , String id ) { this . registry = registry ; this . id = id ; staticTimer = registry . timer ( staticId , id , id ); dynamicId = registry . createId ( dynamicId , id , id ); } public void doSomething ( Context ctxt ) { final long d = ctxt . getDurationMillis (); // Keeping the reference to the timer avoids additional allocations // to create the id object and the lookup cost staticTimer . record ( d , TimeUnit . MILLISECONDS ); // If the id is dynamic it must be looked up registry . timer ( dynamicId , id , id , foo , ctxt . getFoo ()) . record ( d , TimeUnit . MILLISECONDS ); // This will update the same timer as the line above, but the base part // of the id is precomputed to make it cheaper to construct the id. registry . timer ( dynamicId . withTag ( foo , ctxt . getFoo ())) . record ( d , TimeUnit . MILLISECONDS ); } } LongGauge See the general overview of registration differences and summary of gauge usage . Servo: public class Foo { private final LongGauge g = new LongGauge ( MonitorConfig . builder ( name ). build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } } Spectator: public class Foo { private final AtomicLong v ; @Inject public Foo ( Registry registry , String id ) { Id gaugeId = registry . createId ( name ). withTag ( id , id ); v = registry . gauge ( gaugeId , new AtomicLong ()); } } MonitorConfig See the documentation on naming . Servo: MonitorConfig id = MonitorConfig . builder ( name ) . withTag ( country , US ) . withTag ( device , xbox ) . build (); Spectator: Id id = registry . createId ( name ) . withTag ( country , US ) . withTag ( device , xbox ); // or Id id = registry . createId ( name , country , US , device , xbox ); MonitoredCache Not supported because spectator does not have a direct dependency on guava. If there is enough demand an extension can be created. NumberGauge See the general overview of registration differences and summary of gauge usage . Servo: public class Foo { private final NumberGauge g = new NumberGauge ( MonitorConfig . builder ( name ). build (), new AtomicLong ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } } Spectator: public class Foo { private final AtomicLong v ; @Inject public Foo ( Registry registry , String id ) { Id gaugeId = registry . createId ( name ). withTag ( id , id ); v = registry . gauge ( gaugeId , new AtomicLong ()); } } StatsTimer Not supported, see overview of differences . StepCounter See the general overview of registration differences and summary of counter usage . Servo: public class Foo { private final Counter c = new StepCounter ( MonitorConfig . builder ( name ). build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } public void doSomething () { c . increment (); } } Spectator: public class Foo { private final Counter c ; @Inject public Foo ( Registry registry , String id ) { c = registry . counter ( name , id , id ); } public void doSomething () { c . increment (); } }","title":"Servo Comparison"},{"location":"intro/servo-comparison/#servo-comparison","text":"Servo is an alternative client monitoring library that is also developed by Netflix. Originally spectator was an experiment for a simpler API that wrapped servo. It was done as a separate project to avoid breaking backwards compatibility for servo. From a user perspective, both will be supported for a long time, but most of our efforts for future improvement will go to spectator. For new code it is recommended to use the spectator API. If running at Netflix the correct bindings will be in place for both servo and spectator.","title":"Servo Comparison"},{"location":"intro/servo-comparison/#differences","text":"This section provides a quick summary of the differences.","title":"Differences"},{"location":"intro/servo-comparison/#simpler-api","text":"Servo gives the user a lot of control, but this makes it hard to use correctly. For example, to create a counter the user needs to understand the tradeoffs and choose between: BasicCounter DynamicCounter ContextualCounter StepCounter Further each of these can impact how data is reported to observers. The spectator API focuses on the constructs a user needs to instrument the code. In spectator the user would always use the registry to create a Counter . The implementation details are left up to the registry. The registration is simpler as well to avoid common pitfalls when using servo like overwriting a registered object.","title":"Simpler API"},{"location":"intro/servo-comparison/#more-focused","text":"The goal of spectator is instrumenting code to send to a dimensional time-series system like Atlas . Servo has goals of staying compatible with a number of legacy libraries and naming formats, exposing data to JMX, etc. Examples of how this influences decisions: No support for non-numeric data. Servo supported this for exposing to JMX. Exposing the numeric data registered in spectator to JMX can be done using a registry that supports it, but there is no goal to be a general interface for exposing arbitrary data in JMX. No support for customizeable time units when reporting timer data. Base units should always be used for reporting and conversions can be performed in the presentation layer if needed. It also avoids a lot of the confusion around the timer unit for the data and issues like creating aggregates that are meaningless because of mixed units. It is better to have a simple way to get correct and easy to reason about data to the backend than many options. If you want more knobs, then you can use Servo.","title":"More Focused"},{"location":"intro/servo-comparison/#di-friendly","text":"When servo was originally written dependency injection was not heavily used at Netflix. Further servo needed to stay compatible with a number of use-cases that were heavily static. While spectator does have a static registry that can be used, the recommended way is to create a registry and inject it either manually or via a framework into the classes that need it. This also makes it much easier to test in isolation .","title":"DI Friendly"},{"location":"intro/servo-comparison/#migration","text":"If you want to migrate from the servo API to the spectator API, then this section provides some guides on how servo constructs can be ported over. The sub-sections are the class names of monitor types supported by servo. For users at Netflix, note we are not actively pushing teams to migrate or do any additional work. Servo is still supported and if it works for your use-cases feel free to continue using it.","title":"Migration"},{"location":"intro/servo-comparison/#registration","text":"First read through the servo docs on registration . In servo if you have a class like: public class Foo { private AtomicInteger gauge ; private Counter counter ; public Foo ( String id ) { gauge = new AtomicInteger (); counter = new BasicCounter ( MonitorConfig . builder ( counter ). build ()); Monitors . registerObject ( id , this ); } @Monitor ( name = gauge , type = DataSourceType . GAUGE ) private int gauge () { return gauge . get (); } public void doSomething () { ... } } The state of the class is in the member variables of an instance of Foo . If multiple instances of class Foo are created with the same value for id , then the last one will overwrite the others for the registration. So the values getting reported will only be from the last instance registered. Also the registry has a reference to the instance of Foo so it will never go away. For counters and timers one way to get around this is to use DynamicCounter and DynamicTimer respectively. Those classes will automatically handle the registration and expire if there is no activity. They also get used for cases where the set of dimensions is not known up front. Gauges need to sample the state of something so they need to have a reference to an object that contains the state. So the user would need to ensure that only a single copy was registered leading to patterns like: class Foo { private static class FooStats { private AtomicInteger gauge ; private Counter counter ; public FooStats ( String id ) { gauge = new AtomicInteger (); counter = new BasicCounter ( MonitorConfig . builder ( counter ). build ()); Monitors . registerObject ( id , this ); } @Monitor ( name = gauge , type = DataSourceType . GAUGE ) private int gauge () { return gauge . get (); } } private static ConcurrentHashMap String , FooStats STATS = new ConcurrentHashMap (); private final FooStats stats ; public Foo ( String id ) { stats = STATS . computeIfAbsent ( id , ( i ) - new FooStats ( i )); } public void doSomething () { ... stats . update (); } } This ensures that there is a single copy for a given id. In spectator this example would look like: public class Foo { private AtomicInteger gauge ; private Counter counter ; public Foo ( Registry registry , String id ) { Id gaugeId = registry . createId ( gauge ). withTag ( id , id ); gauge = registry . gauge ( gaugeId , new AtomicInteger ()); counter = registry . counter ( counter , id , id ); } public void doSomething () { ... } } Everything using the same registry will get the same counter instance if the same id is used. For the gauge the registry will keep a weak reference and will sum the values if multiple instances are present. Since it is a weak reference, nothing will prevent an instance of Foo from getting garbage collected.","title":"Registration"},{"location":"intro/servo-comparison/#annotations","text":"Annotations are not supported, use the appropriate meter type: DataSourceType Spectator Alternative COUNTER Counter Usage GAUGE Gauge Usage INFORMATIONAL Not supported","title":"Annotations"},{"location":"intro/servo-comparison/#basiccounter","text":"See the general overview of registration differences and summary of counter usage . Servo: public class Foo { private final Counter c = new BasicCounter ( MonitorConfig . builder ( name ). build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } public void doSomething () { c . increment (); } } Spectator: public class Foo { private final Counter c ; @Inject public Foo ( Registry registry , String id ) { c = registry . counter ( name , id , id ); } public void doSomething () { c . increment (); } }","title":"BasicCounter"},{"location":"intro/servo-comparison/#basicgauge","text":"See the general overview of registration differences and summary of gauge usage . Servo: public class Foo { private final BasicGauge g = new BasicGauge ( MonitorConfig . builder ( name ). build (), this :: getCurrentValue ); public Foo ( String id ) { Monitors . registerObject ( id , this ); } } Spectator: public class Foo { @Inject public Foo ( Registry registry , String id ) { Id gaugeId = registry . createId ( name ). withTag ( id , id ); registry . gauge ( gaugeId , this , Foo :: getCurrentValue ); } }","title":"BasicGauge"},{"location":"intro/servo-comparison/#basictimer","text":"See the general overview of registration differences and summary of timer usage . Note in spectator the reported unit for timers is always seconds and cannot be changed. Seconds is the base unit and other units should only be used as a presentation detail. Servo allows the unit to be customized and defaults to milliseconds. Servo: public class Foo { private final Timer t = new BasicTimer ( MonitorConfig . builder ( name ). build (), TimeUnit . SECONDS ); public Foo ( String id ) { Monitors . registerObject ( id , this ); } public void doSomething () { Stopwatch s = t . start (); try { ... } finally { s . stop (); } } } Spectator: public class Foo { private final Timer t ; @Inject public Foo ( Registry registry , String id ) { t = registry . timer ( name , id , id ); } public void doSomething () { t . record (() - { ... }); } }","title":"BasicTimer"},{"location":"intro/servo-comparison/#basicdistributionsummary","text":"See the general overview of registration differences and summary of distribution summary usage . Servo: public class Foo { private final BasicDistributionSummary s = new BasicDistributionSummary ( MonitorConfig . builder ( name ). build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } public void doSomething () { ... s . record ( getValue ()); } } Spectator: public class Foo { private final DistributionSummary s ; @Inject public Foo ( Registry registry , String id ) { s = registry . distributionSummary ( name , id , id ); } public void doSomething () { ... s . record ( getValue ()); } }","title":"BasicDistributionSummary"},{"location":"intro/servo-comparison/#basicinformational","text":"Not supported, see overview of differences .","title":"BasicInformational"},{"location":"intro/servo-comparison/#basicstopwatch","text":"There isn't an explicit stopwatch class in spectator. Just use a timing call directly. Servo: public void doSomething () { Stopwatch s = timer . start (); try { ... } finally { s . stop (); } } Spectator: public void doSomething () { final long s = System . nanoTime (); try { ... } finally { timer . record ( System . nanoTime () - s , TimeUnit . NANOSECONDS ); } }","title":"BasicStopwatch"},{"location":"intro/servo-comparison/#buckettimer","text":"See the general overview of registration differences and summary of sandbox documentation . Note in spectator BucketTimer is provided in the sandbox extension library and may change in future as we gain more experience using it. Servo: public class Foo { private final Timer t = new BucketTimer ( MonitorConfig . builder ( name ). build (), new BucketConfig . Builder () . withTimeUnit ( TimeUnit . MILLISECONDS ) . withBuckets ( new long [] { 500 , 2500 , 5000 , 10000 }) . build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } public void doSomething () { Stopwatch s = t . start (); try { ... } finally { s . stop (); } } } Spectator: public class Foo { private final Timer t ; @Inject public Foo ( Registry registry , String id ) { Id timerId = registry . createId ( name , id , id ); BucketFunction f = BucketFunctions . latency ( 10 , TimeUnit . SECONDS ); t = BucketTimer . get ( registry , timerId , f ); } public void doSomething () { t . record (() - { ... }); } }","title":"BucketTimer"},{"location":"intro/servo-comparison/#contextualcounter","text":"Not supported. A fixed tag list for the context is too rigid and this class was never used much at Netflix. Future work being looked at in issue-180 .","title":"ContextualCounter"},{"location":"intro/servo-comparison/#contextualtimer","text":"Not supported. A fixed tag list for the context is too rigid and this class was never used much at Netflix. Future work being looked at in issue-180 .","title":"ContextualTimer"},{"location":"intro/servo-comparison/#doublegauge","text":"See the general overview of registration differences and summary of gauge usage . Servo: public class Foo { private final DoubleGauge g = new DoubleGauge ( MonitorConfig . builder ( name ). build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } } Spectator: import com.google.common.util.concurrent.AtomicDouble ; public class Foo { private final AtomicDouble v ; @Inject public Foo ( Registry registry , String id ) { Id gaugeId = registry . createId ( name ). withTag ( id , id ); v = registry . gauge ( gaugeId , new AtomicDouble ()); } }","title":"DoubleGauge"},{"location":"intro/servo-comparison/#durationtimer","text":"See the general overview of registration differences and summary of timer usage . Servo: public class Foo { private final DurationTimer t = new DurationTimer ( MonitorConfig . builder ( name ). build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } } Spectator: public class Foo { private final LongTaskTimer t ; @Inject public Foo ( Registry registry , String id ) { t = registry . longTaskTimer ( name , id , id ); } }","title":"DurationTimer"},{"location":"intro/servo-comparison/#dynamiccounter","text":"See the general overview of registration differences and summary of counter usage . Servo: public class Foo { private final String id ; public Foo ( String id ) { this . id = id ; } public void doSomething ( Context ctxt ) { DynamicCounter . increment ( staticId , id , id ); DynamicCounter . increment ( dynamicId , id , id , foo , ctxt . getFoo ()); } } Spectator: public class Foo { private final Registry registry ; private final String id ; private final Counter staticCounter ; private final Id dynamicId ; @Inject public Foo ( Registry registry , String id ) { this . registry = registry ; this . id = id ; staticCounter = registry . counter ( staticId , id , id ); dynamicId = registry . createId ( dynamicId , id , id ); } public void doSomething ( Context ctxt ) { // Keeping the reference to the counter avoids additional allocations // to create the id object and the lookup cost staticCounter . increment (); // If the id is dynamic it must be looked up registry . counter ( dynamicId , id , id , foo , ctxt . getFoo ()). increment (); // This will update the same counter as the line above, but the base part // of the id is precomputed to make it cheaper to construct the id. registry . counter ( dynamicId . withTag ( foo , ctxt . getFoo ())). increment (); } }","title":"DynamicCounter"},{"location":"intro/servo-comparison/#dynamictimer","text":"See the general overview of registration differences and summary of timer usage . Servo: public class Foo { private final String id ; private final MonitorConfig staticId ; public Foo ( String id ) { this . id = id ; staticId = MonitorConfig . builder ( staticId ). withTag ( id , id ). build (); } public void doSomething ( Context ctxt ) { final long d = ctxt . getDurationMillis (); DynamicTimer . record ( staticId , TimeUnit . SECONDS , d , TimeUnit . MILLISECONDS ); MonitorConfig dynamicId = MonitorConfig . builder ( dynamicId ) . withTag ( id , id ) . withTag ( foo , ctxt . getFoo ()) . build (); DynamicTimer . record ( dynamicId , TimeUnit . SECONDS , d , TimeUnit . MILLISECONDS ); } } Spectator: public class Foo { private final Registry registry ; private final String id ; private final Timer staticTimer ; private final Id dynamicId ; @Inject public Foo ( Registry registry , String id ) { this . registry = registry ; this . id = id ; staticTimer = registry . timer ( staticId , id , id ); dynamicId = registry . createId ( dynamicId , id , id ); } public void doSomething ( Context ctxt ) { final long d = ctxt . getDurationMillis (); // Keeping the reference to the timer avoids additional allocations // to create the id object and the lookup cost staticTimer . record ( d , TimeUnit . MILLISECONDS ); // If the id is dynamic it must be looked up registry . timer ( dynamicId , id , id , foo , ctxt . getFoo ()) . record ( d , TimeUnit . MILLISECONDS ); // This will update the same timer as the line above, but the base part // of the id is precomputed to make it cheaper to construct the id. registry . timer ( dynamicId . withTag ( foo , ctxt . getFoo ())) . record ( d , TimeUnit . MILLISECONDS ); } }","title":"DynamicTimer"},{"location":"intro/servo-comparison/#longgauge","text":"See the general overview of registration differences and summary of gauge usage . Servo: public class Foo { private final LongGauge g = new LongGauge ( MonitorConfig . builder ( name ). build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } } Spectator: public class Foo { private final AtomicLong v ; @Inject public Foo ( Registry registry , String id ) { Id gaugeId = registry . createId ( name ). withTag ( id , id ); v = registry . gauge ( gaugeId , new AtomicLong ()); } }","title":"LongGauge"},{"location":"intro/servo-comparison/#monitorconfig","text":"See the documentation on naming . Servo: MonitorConfig id = MonitorConfig . builder ( name ) . withTag ( country , US ) . withTag ( device , xbox ) . build (); Spectator: Id id = registry . createId ( name ) . withTag ( country , US ) . withTag ( device , xbox ); // or Id id = registry . createId ( name , country , US , device , xbox );","title":"MonitorConfig"},{"location":"intro/servo-comparison/#monitoredcache","text":"Not supported because spectator does not have a direct dependency on guava. If there is enough demand an extension can be created.","title":"MonitoredCache"},{"location":"intro/servo-comparison/#numbergauge","text":"See the general overview of registration differences and summary of gauge usage . Servo: public class Foo { private final NumberGauge g = new NumberGauge ( MonitorConfig . builder ( name ). build (), new AtomicLong ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } } Spectator: public class Foo { private final AtomicLong v ; @Inject public Foo ( Registry registry , String id ) { Id gaugeId = registry . createId ( name ). withTag ( id , id ); v = registry . gauge ( gaugeId , new AtomicLong ()); } }","title":"NumberGauge"},{"location":"intro/servo-comparison/#statstimer","text":"Not supported, see overview of differences .","title":"StatsTimer"},{"location":"intro/servo-comparison/#stepcounter","text":"See the general overview of registration differences and summary of counter usage . Servo: public class Foo { private final Counter c = new StepCounter ( MonitorConfig . builder ( name ). build ()); public Foo ( String id ) { Monitors . registerObject ( id , this ); } public void doSomething () { c . increment (); } } Spectator: public class Foo { private final Counter c ; @Inject public Foo ( Registry registry , String id ) { c = registry . counter ( name , id , id ); } public void doSomething () { c . increment (); } }","title":"StepCounter"},{"location":"intro/testing/","text":"Testing Testing should be relatively straightforward if you are using injection for the registry. Consider a sample class: public class Foo { private final Counter counter ; @Inject public Foo ( Registry registry ) { counter = registry . counter ( foo ); } public void doSomething () { counter . increment (); } } Tests will typically want to use an isolated instance of the DefaultRegistry . Simple Test A basic standalone test class would look something like: public class FooTest { private Registry registry ; private Foo foo ; @Before public void init () { registry = new DefaultRegistry (); foo = new Foo ( registry ); } @Test public void doSomething () { foo . doSomething (); Assert . assertEquals ( 1 , registry . counter ( foo ). count ()); } } Guice Test If using guice, then the TestModule can be used: public class FooTest { private Registry registry ; private Foo foo ; @Before public void init () { Injector injector = Guice . createInjector ( new TestModule ()); registry = injector . getInstance ( Registry . class ); foo = injector . getInstance ( Foo . class ); } @Test public void doSomething () { foo . doSomething (); Assert . assertEquals ( 1 , registry . counter ( foo ). count ()); } } Exceptions By default, for most user errors Spectator will log a warning rather than throw an exception. The rationale is that users do not often think about instrumentation and logging code causing an exception and interrupting the control flow of a program. However, for test cases it is recommended to be more aggressive and learn about problems as early as possible. This can be done by setting a system property: spectator.api.propagateWarnings=true Consider an example: private static final Id RARE_EXCEPTION_ID = null ; public void doSomethingImportant () { try { ... do work ... } catch ( RareException e ) { // There is a bug in the program, an Id is not allowed to be null. In production we do // not want it to throw and interrupt the control flow. Instrumentation should gracefully // degrade. registry . counter ( RARE_EXCEPTION_ID ). increment (); // These statements are important to provide context for operating the system // and to ensure the app continues to function properly. LOGGER . error ( important context for user , e ); properlyHandleException ( e ); } }","title":"Testing"},{"location":"intro/testing/#testing","text":"Testing should be relatively straightforward if you are using injection for the registry. Consider a sample class: public class Foo { private final Counter counter ; @Inject public Foo ( Registry registry ) { counter = registry . counter ( foo ); } public void doSomething () { counter . increment (); } } Tests will typically want to use an isolated instance of the DefaultRegistry .","title":"Testing"},{"location":"intro/testing/#simple-test","text":"A basic standalone test class would look something like: public class FooTest { private Registry registry ; private Foo foo ; @Before public void init () { registry = new DefaultRegistry (); foo = new Foo ( registry ); } @Test public void doSomething () { foo . doSomething (); Assert . assertEquals ( 1 , registry . counter ( foo ). count ()); } }","title":"Simple Test"},{"location":"intro/testing/#guice-test","text":"If using guice, then the TestModule can be used: public class FooTest { private Registry registry ; private Foo foo ; @Before public void init () { Injector injector = Guice . createInjector ( new TestModule ()); registry = injector . getInstance ( Registry . class ); foo = injector . getInstance ( Foo . class ); } @Test public void doSomething () { foo . doSomething (); Assert . assertEquals ( 1 , registry . counter ( foo ). count ()); } }","title":"Guice Test"},{"location":"intro/testing/#exceptions","text":"By default, for most user errors Spectator will log a warning rather than throw an exception. The rationale is that users do not often think about instrumentation and logging code causing an exception and interrupting the control flow of a program. However, for test cases it is recommended to be more aggressive and learn about problems as early as possible. This can be done by setting a system property: spectator.api.propagateWarnings=true Consider an example: private static final Id RARE_EXCEPTION_ID = null ; public void doSomethingImportant () { try { ... do work ... } catch ( RareException e ) { // There is a bug in the program, an Id is not allowed to be null. In production we do // not want it to throw and interrupt the control flow. Instrumentation should gracefully // degrade. registry . counter ( RARE_EXCEPTION_ID ). increment (); // These statements are important to provide context for operating the system // and to ensure the app continues to function properly. LOGGER . error ( important context for user , e ); properlyHandleException ( e ); } }","title":"Exceptions"},{"location":"intro/timer/","text":"Timers A timer is used to measure how long (in seconds) some event is taking. Two types of timers are supported: Timer : for frequent short duration events. LongTaskTimer : for long running tasks. The long duration timer is setup so that you can track the time while an event being measured is still running. A regular timer just records the duration and has no information until the task is complete. As an example, consider a chart showing request latency to a typical web server. The expectation is many short requests so the timer will be getting updated many times per second. Now consider a background process to refresh metadata from a data store. For example, Edda caches AWS resources such as instances, volumes, auto-scaling groups etc. Normally all data can be refreshed in a few minutes. If the AWS services are having problems it can take much longer. A long duration timer can be used to track the overall time for refreshing the metadata. The charts below show max latency for the refresh using a regular timer and a long task timer. Regular timer, note that the y-axis is using a logarithmic scale: Long task timer: Timer To get started create an instance using the registry: public class Server { private final Registry registry ; private final Timer requestLatency ; @Inject public Server ( Registry registry ) { this . registry = registry ; requestLatency = registry . timer ( server.requestLatency ); } Then wrap the call you need to measure, preferably using a lambda: public Response handle ( Request request ) { return requestLatency . record (() - handleImpl ( request )); } The lambda variants will handle exceptions for you and ensure the record happens as part of a finally block using the monotonic time. It could also have been done more explicitly like: public Response handle ( Request request ) { final long start = registry . clock (). monotonicTime (); try { return handleImpl ( request ); } finally { final long end = registry . clock (). monotonicTime (); requestLatency . record ( end - start , TimeUnit . NANOSECONDS ); } } This example uses the clock from the registry which can be useful for testing if you need to control the timing. In actual usage it will typically get mapped to the system clock. It is recommended to use a monotonically increasing source for measuring the times to avoid occasionally having bogus measurements due to time adjustments. For more information see the Clock documentation . LongTaskTimer To get started create an instance using the registry: import com.netflix.spectator.api.patterns.LongTaskTimer ; public class MetadataService { private final LongTaskTimer metadataRefresh ; @Inject public MetadataService ( Registry registry ) { metadataRefresh = LongTaskTimer . get ( registry , registry . createId ( metadata.refreshDuration )); // setup background thread to call refresh() } private void refresh () { final int id = metadataRefresh . start (); try { refreshImpl (); } finally { metadataRefresh . stop ( id ); } } The id value returned by the start method is used to keep track of a particular task being measured by the timer. It must be stopped using the provided id. Note that unlike a regular timer that does not do anything until the final duration is recorded, a long duration timer will report as two gauges: duration : total duration spent within all currently running tasks. activeTasks : number of currently running tasks. This means that you can see what is happening while the task is running, but you need to keep in mind: The meter id is fixed before the task begins. There is no way to change tags based on the run, e.g., update a different timer if an exception is thrown. Being a gauge it is inappropriate for short tasks. In particular, gauges are sampled and if it is not sampled during the execution or the sampling period is a significant subset of the expected duration, then the duration value will not be meaningful. Like a regular timer, the duration timer also supports using a lambda to simplify the common case: private void refresh () { metadataRefresh . record ( this :: refreshImpl ); }","title":"Timers"},{"location":"intro/timer/#timers","text":"A timer is used to measure how long (in seconds) some event is taking. Two types of timers are supported: Timer : for frequent short duration events. LongTaskTimer : for long running tasks. The long duration timer is setup so that you can track the time while an event being measured is still running. A regular timer just records the duration and has no information until the task is complete. As an example, consider a chart showing request latency to a typical web server. The expectation is many short requests so the timer will be getting updated many times per second. Now consider a background process to refresh metadata from a data store. For example, Edda caches AWS resources such as instances, volumes, auto-scaling groups etc. Normally all data can be refreshed in a few minutes. If the AWS services are having problems it can take much longer. A long duration timer can be used to track the overall time for refreshing the metadata. The charts below show max latency for the refresh using a regular timer and a long task timer. Regular timer, note that the y-axis is using a logarithmic scale: Long task timer:","title":"Timers"},{"location":"intro/timer/#timer","text":"To get started create an instance using the registry: public class Server { private final Registry registry ; private final Timer requestLatency ; @Inject public Server ( Registry registry ) { this . registry = registry ; requestLatency = registry . timer ( server.requestLatency ); } Then wrap the call you need to measure, preferably using a lambda: public Response handle ( Request request ) { return requestLatency . record (() - handleImpl ( request )); } The lambda variants will handle exceptions for you and ensure the record happens as part of a finally block using the monotonic time. It could also have been done more explicitly like: public Response handle ( Request request ) { final long start = registry . clock (). monotonicTime (); try { return handleImpl ( request ); } finally { final long end = registry . clock (). monotonicTime (); requestLatency . record ( end - start , TimeUnit . NANOSECONDS ); } } This example uses the clock from the registry which can be useful for testing if you need to control the timing. In actual usage it will typically get mapped to the system clock. It is recommended to use a monotonically increasing source for measuring the times to avoid occasionally having bogus measurements due to time adjustments. For more information see the Clock documentation .","title":"Timer"},{"location":"intro/timer/#longtasktimer","text":"To get started create an instance using the registry: import com.netflix.spectator.api.patterns.LongTaskTimer ; public class MetadataService { private final LongTaskTimer metadataRefresh ; @Inject public MetadataService ( Registry registry ) { metadataRefresh = LongTaskTimer . get ( registry , registry . createId ( metadata.refreshDuration )); // setup background thread to call refresh() } private void refresh () { final int id = metadataRefresh . start (); try { refreshImpl (); } finally { metadataRefresh . stop ( id ); } } The id value returned by the start method is used to keep track of a particular task being measured by the timer. It must be stopped using the provided id. Note that unlike a regular timer that does not do anything until the final duration is recorded, a long duration timer will report as two gauges: duration : total duration spent within all currently running tasks. activeTasks : number of currently running tasks. This means that you can see what is happening while the task is running, but you need to keep in mind: The meter id is fixed before the task begins. There is no way to change tags based on the run, e.g., update a different timer if an exception is thrown. Being a gauge it is inappropriate for short tasks. In particular, gauges are sampled and if it is not sampled during the execution or the sampling period is a significant subset of the expected duration, then the duration value will not be meaningful. Like a regular timer, the duration timer also supports using a lambda to simplify the common case: private void refresh () { metadataRefresh . record ( this :: refreshImpl ); }","title":"LongTaskTimer"},{"location":"registry/metrics3/","text":"Metrics3 Registry Registry that uses metrics3 as the underlying implementation. To use the metrics registry, add a dependency on the spectator-reg-metrics3 library. For gradle: com.netflix.spectator:spectator-reg-metrics3:0.83.0 Then when initializing the application, use the MetricsRegistry . For more information see the metrics3 example .","title":"Metrics3"},{"location":"registry/metrics3/#metrics3-registry","text":"Registry that uses metrics3 as the underlying implementation. To use the metrics registry, add a dependency on the spectator-reg-metrics3 library. For gradle: com.netflix.spectator:spectator-reg-metrics3:0.83.0 Then when initializing the application, use the MetricsRegistry . For more information see the metrics3 example .","title":"Metrics3 Registry"},{"location":"registry/servo/","text":"Servo Registry Warning ServoRegistry is deprecated. If you are running internally at Netflix, see the Netflix Integration docs instead. Registry that uses servo as the underlying implementation. To use the servo registry, add a dependency on the spectator-reg-servo library. For gradle: com.netflix.spectator:spectator-reg-servo:0.83.0 Then when initializing the application, use the ServoRegistry . If using guice then that would look like: Injector injector = Guice . createInjector ( new AbstractModule () { @Override protected void configure () { } @Provides @Singleton private Registry providesRegistry () { return new ServoRegistry (); } }); For more information see the servo example .","title":"Servo"},{"location":"registry/servo/#servo-registry","text":"Warning ServoRegistry is deprecated. If you are running internally at Netflix, see the Netflix Integration docs instead. Registry that uses servo as the underlying implementation. To use the servo registry, add a dependency on the spectator-reg-servo library. For gradle: com.netflix.spectator:spectator-reg-servo:0.83.0 Then when initializing the application, use the ServoRegistry . If using guice then that would look like: Injector injector = Guice . createInjector ( new AbstractModule () { @Override protected void configure () { } @Provides @Singleton private Registry providesRegistry () { return new ServoRegistry (); } }); For more information see the servo example .","title":"Servo Registry"}]}